---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: Verimli bir şekilde büyük miktarlarda verinin (C#) disk belleği | Microsoft Docs
author: rick-anderson
description: Varsayılan disk belleği veri sunu denetiminin büyük miktarlarda verinin, temel alınan veri kaynağı denetimi retriev olarak çalışırken uygun seçenektir...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: ea1fd06f8eb7c53c3e9e7fb10c46974eb2af2acd
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/06/2018
---
<a name="efficiently-paging-through-large-amounts-of-data-c"></a><span data-ttu-id="9acc4-103">Verimli bir şekilde büyük miktarlarda verinin (C#) disk belleği</span><span class="sxs-lookup"><span data-stu-id="9acc4-103">Efficiently Paging Through Large Amounts of Data (C#)</span></span>
====================
<span data-ttu-id="9acc4-104">tarafından [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="9acc4-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="9acc4-105">[Örnek uygulamayı indirin](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) veya [PDF indirin](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="9acc4-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span></span>

> <span data-ttu-id="9acc4-106">Yalnızca bir veri alt kümesini görüntülenmesine karşın, temel alınan veri kaynağı denetimi tüm kayıtları alır gibi varsayılan disk belleği veri sunu denetimi büyük miktarlarda verilerin çalışırken uygunsuz seçeneğidir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="9acc4-107">Böyle durumlarda, biz özel etkinleştirmelisiniz sayfalama.</span><span class="sxs-lookup"><span data-stu-id="9acc4-107">In such circumstances, we must turn to custom paging.</span></span>


## <a name="introduction"></a><span data-ttu-id="9acc4-108">Giriş</span><span class="sxs-lookup"><span data-stu-id="9acc4-108">Introduction</span></span>

<span data-ttu-id="9acc4-109">Biz önceki öğreticide açıklandığı gibi disk belleği iki yoldan biriyle uygulanabilir:</span><span class="sxs-lookup"><span data-stu-id="9acc4-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="9acc4-110">**Varsayılan disk belleği** etkinleştirmek disk belleği seçeneği denetleyerek uygulanabilir veri Web denetimi s akıllı etiketi; ancak, bir sayfa veri görüntüleme her ObjectDataSource alır *tüm* kayıtları, hatta ancak yalnızca bir alt kümesini görüntülenir sayfasında</span><span class="sxs-lookup"><span data-stu-id="9acc4-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="9acc4-111">**Özel sayfalama** varsayılan performansını artırır, kullanıcı tarafından; istenen veri belirli sayfasının görüntülenmesi gereken veritabanından yalnızca kayıtları alarak disk belleği ancak, özel sayfalama uygulamak için biraz daha fazla çaba içerir varsayılan disk belleği'den</span><span class="sxs-lookup"><span data-stu-id="9acc4-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="9acc4-112">Uygulama yalnızca onay bir onay kutusu ve yapıldığı kolaylığı nedeniyle bitti!</span><span class="sxs-lookup"><span data-stu-id="9acc4-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="9acc4-113">varsayılan disk belleği çekici bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-113">default paging is an attractive option.</span></span> <span data-ttu-id="9acc4-114">Tüm kayıtları alınırken na ullanıcı yaklaşım yine de bir implausible seçim yeterince büyük miktarlarda veri veya siteler için aracılığıyla ile çok sayıda eşzamanlı kullanıcıyı sayfalama kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="9acc4-115">Böyle durumlarda, biz esnek bir sistem sağlamak için disk belleği özel kapatmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="9acc4-116">Özel sayfalama sınama hassas verilerin belirli bir sayfa için gerekli kayıt kümesini döndüren bir sorgu yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="9acc4-117">Neyse ki, Microsoft SQL Server 2005'in yeni bir anahtar sözcük derecelendirme sonuçlar için bize kapsanır kayıtların verimli bir şekilde alabilir bir sorgu yazmak sağlayan sağlar.</span><span class="sxs-lookup"><span data-stu-id="9acc4-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="9acc4-118">Bu öğreticide bir GridView denetiminde özel sayfalama uygulamak için bu yeni SQL Server 2005'in anahtar sözcüğü kullanmayı göreceğiz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="9acc4-119">Özel sayfalama için kullanıcı arabirimi aynı varsayılan disk belleği, sonraki kullanarak bir sayfadan diğerine atlama için özel sayfalama birkaç varsayılan disk belleği daha hızlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="9acc4-120">Özel sayfalama tarafından sergilenen tam performans kazancı aracılığıyla havuzda kayıtlarının ve veritabanı sunucusuna yerleştirilen yük toplam sayısına bağlı olarak değişir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="9acc4-121">Bu öğreticinin sonunda avantajları elde size özel disk belleği performans sergiler bazı kaba ölçümleri inceleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>


## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="9acc4-122">1. adım: özel disk belleği işlemi anlama</span><span class="sxs-lookup"><span data-stu-id="9acc4-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="9acc4-123">Verilerine disk belleği, istenen veri sayfasını ve sayfa başına görüntülenen kayıtlarının sayısı üzerinde bir sayfasında görüntülenen kesin kayıt bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="9acc4-124">Örneğin, biz 81 ürünleri üzerinden sayfasında sayfa başına 10 ürün görüntüleme istediğinizi düşünelim.</span><span class="sxs-lookup"><span data-stu-id="9acc4-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="9acc4-125">İlk sayfa görüntülerken, d ürünleri 1 ile 10 istiyoruz; İkinci sayfa görüntülerken d biz ürünleri 11 ile 20 ve benzeri içindir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="9acc4-126">Kayıtları alınması gerekenler ve disk belleği arabirimi nasıl işleneceğini dikte üç değişkenleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="9acc4-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="9acc4-127">**Satır dizini Başlat** ilk satırının sayfasında görüntülenecek veri dizinini; sayfa başına görüntülenecek kayıt tarafından sayfa dizini çarparak ve eklenirken bir hesaplanan dizin olabilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="9acc4-128">Örneğin, 10, her seferinde için kayıtları (sayfa dizinini: 0) ilk sayfa aracılığıyla disk belleği, başlangıç satır dizini 0'dır \* 10 + 1 veya 1; (1, sayfa dizini'dir) İkinci sayfa için 1 Başlat satır dizini \* 10 + 1 , veya 11.</span><span class="sxs-lookup"><span data-stu-id="9acc4-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="9acc4-129">**En fazla satır** en fazla sayfa başına görüntülenecek kayıt sayısı.</span><span class="sxs-lookup"><span data-stu-id="9acc4-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="9acc4-130">İçin en son döndürülen sayfa boyutundan daha az kayıt sayfasını olabileceğinden bu değişkeni, en fazla satır adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="9acc4-131">Örneğin, sayfa başına 81 ürünleri 10 kayıt üzerinden disk belleği, dokuzuncu ve son sayfası yalnızca bir kayıt olur.</span><span class="sxs-lookup"><span data-stu-id="9acc4-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="9acc4-132">Hiçbir sayfa rağmen en fazla satır değerden daha fazla kayıt gösterir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="9acc4-133">**Toplam kayıt sayısı** aracılığıyla havuzda kayıtlarının toplam sayısı.</span><span class="sxs-lookup"><span data-stu-id="9acc4-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="9acc4-134">Hangi kayıtların için belirli bir sayfa alınacağını belirlemek bu değişkeni olmayan t gerekli olsa da, disk belleği arabirimi dikte etmez.</span><span class="sxs-lookup"><span data-stu-id="9acc4-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="9acc4-135">Örneğin, aracılığıyla havuzda 81 ürün varsa, disk belleği UI dokuz sayfa sayıları görüntülemek için sayfalama arabirimi bilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="9acc4-136">Varsayılan disk belleği ile en fazla satır yalnızca sayfa boyutu iken Başlat satır dizini sayfa dizini ve sayfa boyutu ve bir ürün olarak hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="9acc4-137">Varsayılan disk belleği tüm kayıtlarını alır. bu yana böylece Başlat satır dizini satır karmaşık bir görev taşıma yapmadan herhangi bir sayfayı veri, her satır için dizin oluşturma sırasında veritabanı denir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="9acc4-138">Ayrıca, toplam kayıt sayısı olarak kullanıma hazır s yalnızca DataTable (veya nesneyi veritabanı sonuçları tutmak için kullanılan) kayıt sayısı.</span><span class="sxs-lookup"><span data-stu-id="9acc4-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="9acc4-139">Satır dizini başlatmak ve en fazla satır değişkenleri göz önüne alındığında, özel bir disk belleği uygulamasını yalnızca kesin kayıt alt kümesini Başlat satır dizini ve kayıt en fazla satır sayısı kadar bundan sonra Başlangıç döndürmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="9acc4-140">Özel sayfalama iki zorluk sağlar:</span><span class="sxs-lookup"><span data-stu-id="9acc4-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="9acc4-141">Biz verimli bir şekilde aracılığıyla biz belirtilen başlangıç satırı dizinde kayıtları döndürme başlayabilmeniz için disk belleği tüm veri her satırda bir satır dizini ilişkilendirmek için</span><span class="sxs-lookup"><span data-stu-id="9acc4-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="9acc4-142">Biz aracılığıyla havuzda kayıtlarının toplam sayısı sağlanması gerekiyor</span><span class="sxs-lookup"><span data-stu-id="9acc4-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="9acc4-143">Sonraki iki adımda Biz bu iki zorluk yanıt vermek için gereken SQL komut dosyası inceleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="9acc4-144">SQL komut dosyası ek olarak, biz de DAL ve BLL yöntemleri uygulamak gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="9acc4-145">2. adım: aracılığıyla havuzda kayıtlarının toplam sayısı döndürme</span><span class="sxs-lookup"><span data-stu-id="9acc4-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="9acc4-146">Sayfa görüntülenmesine kayıtları hassas alt alma inceleyeceğiz önce aracılığıyla havuzda kayıtlarının toplam sayısını döndürmek nasıl ilk bakmak s olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="9acc4-147">Bu bilgiler, disk belleği kullanıcı arabirimi düzgün bir şekilde yapılandırmak için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="9acc4-148">Belirli bir SQL sorgusu tarafından döndürülen kayıt toplam sayısını kullanarak elde edilebilir [ `COUNT` toplama işlevi](https://msdn.microsoft.com/library/ms175997.aspx).</span><span class="sxs-lookup"><span data-stu-id="9acc4-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="9acc4-149">Örneğin, kayıtlarının toplam sayısını belirlemek için `Products` tablo, aşağıdaki sorguyu kullanırız:</span><span class="sxs-lookup"><span data-stu-id="9acc4-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

<span data-ttu-id="9acc4-150">Bu bilgiler verir bizim DAL için bir yöntem ekleyin s olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="9acc4-151">Adlı bir DAL yöntemi özellikle oluşturacağız `TotalNumberOfProducts()` yürütmelerinin `SELECT` yukarıda gösterilen deyimi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="9acc4-152">Başlangıç açarak `Northwind.xsd` yazılan veri kümesi dosyasında `App_Code/DAL` klasör.</span><span class="sxs-lookup"><span data-stu-id="9acc4-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="9acc4-153">Ardından, sağ tıklayın `ProductsTableAdapter` Tasarımcısı'nda ve Sorgu Ekle'i seçin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="9acc4-154">Biz olarak önceki eğitimlerine görülen ve bu yeni bir yöntemi DAL ile eklemek için bize izin verir, belirli SQL deyimi veya saklı yordam çağrıldığında, yürütülür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="9acc4-155">Olarak geçici SQL deyimi kullanmak için bu bir önceki öğreticileri yöntemlerinde bizim TableAdapter ile tercih.</span><span class="sxs-lookup"><span data-stu-id="9acc4-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>


![Geçici SQL deyimini kullanın](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

<span data-ttu-id="9acc4-157">**Şekil 1**: geçici SQL deyimini kullanın</span><span class="sxs-lookup"><span data-stu-id="9acc4-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>


<span data-ttu-id="9acc4-158">Sonraki ekranda biz oluşturmak için sorgu türünü belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="9acc4-159">Bu sorgu kayıtlarının toplam sayısı skaler, tek bir değer döndürür beri `Products` tablo seçin `SELECT` singe değeri seçeneği döndürür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>


![Sorgu tek bir değer döndüren bir SELECT deyimi kullanacak şekilde yapılandırma](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

<span data-ttu-id="9acc4-161">**Şekil 2**: tek bir değer döndüren bir SELECT deyimi kullanılacak sorguyu yapılandırın</span><span class="sxs-lookup"><span data-stu-id="9acc4-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>


<span data-ttu-id="9acc4-162">Kullanmak için sorgu türünü gösteren sonra biz sonraki sorgu belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-162">After indicating the type of query to use, we must next specify the query.</span></span>


![SELECT COUNT(\*) ürünleri SORGUDAN kullanın](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

<span data-ttu-id="9acc4-164">**Şekil 3**: SELECT sayısını kullan (\*) FROM ürünleri sorgu</span><span class="sxs-lookup"><span data-stu-id="9acc4-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>


<span data-ttu-id="9acc4-165">Son olarak, yöntemin adını belirtin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="9acc4-166">Daha önce bahsedilen, let s olarak kullanmak `TotalNumberOfProducts`.</span><span class="sxs-lookup"><span data-stu-id="9acc4-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>


![DAL yöntemi TotalNumberOfProducts adı](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

<span data-ttu-id="9acc4-168">**Şekil 4**: DAL yöntemi TotalNumberOfProducts adı</span><span class="sxs-lookup"><span data-stu-id="9acc4-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>


<span data-ttu-id="9acc4-169">Son'u tıklattıktan sonra Sihirbazı ekleyecek `TotalNumberOfProducts` DAL yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="9acc4-170">SQL sorgusu sonuç olması durumunda boş değer atanabilir türler DAL skaler döndürmeyi yöntemlerinde dönüş `NULL`.</span><span class="sxs-lookup"><span data-stu-id="9acc4-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="9acc4-171">Bizim `COUNT` sorgu, ancak her zaman döndürecektir olmayan bir`NULL` değeri; ne olursa olsun, DAL yöntemi boş değer atanabilir bir tamsayı döndürür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="9acc4-172">DAL yöntemi ek olarak, biz de BLL yönteminde gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="9acc4-173">Açık `ProductsBLL` sınıf dosya ve ekleme bir `TotalNumberOfProducts` DAL s yalnızca çağıran yöntemi `TotalNumberOfProducts` yöntemi:</span><span class="sxs-lookup"><span data-stu-id="9acc4-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

<span data-ttu-id="9acc4-174">DAL s `TotalNumberOfProducts` yöntemi boş değer atanabilir bir tamsayı döndürür; ancak biz oluşturulan ve `ProductsBLL` s sınıfı `TotalNumberOfProducts` olan standart bir tamsayı döndürecek şekilde yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="9acc4-175">Bu nedenle, biz gerek `ProductsBLL` s sınıfı `TotalNumberOfProducts` döndürme DAL s tarafından döndürülen boş değer atanabilir tamsayı değeri kısmı `TotalNumberOfProducts` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="9acc4-176">Çağrı `GetValueOrDefault()` varsa; boş değer atanabilir tamsayı ise, boş değer atanabilir tamsayı değerini döndürür `null`, ancak varsayılan tamsayı değeri, 0 döndürür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="9acc4-177">3. adım: kayıtları hassas alt döndürme</span><span class="sxs-lookup"><span data-stu-id="9acc4-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="9acc4-178">Bizim sonraki görev DAL ve başlangıç satır dizini kabul BLL yöntemleri oluşturmak için ve en fazla satır değişkenleri daha önce bahsedilen ve uygun kayıtları döndürür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="9acc4-179">Bunu yapmadan let s ilk bakış gereken SQL komut.</span><span class="sxs-lookup"><span data-stu-id="9acc4-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="9acc4-180">Bize karşılıklı biz verimli bir şekilde biz yalnızca bu kayıtları Başlat satır dizini (ve kayıtları en fazla kayıt sayısı kadar) başlangıç dönebilmek üzerinden disk belleği tüm sonuçları her satır için bir dizin atamak sahibi olması iştir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="9acc4-181">Bu bir sınama değil, zaten varsa bir sütun veritabanı tablosundaki satır dizini görev yapar.</span><span class="sxs-lookup"><span data-stu-id="9acc4-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="9acc4-182">İlk bakışta, düşünüyoruz `Products` s tablosu `ProductID` alan yeterli, ilk ürün taşıdığından `ProductID` 1, 2, ikinci ve benzeri.</span><span class="sxs-lookup"><span data-stu-id="9acc4-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="9acc4-183">Ancak, bir ürün silinmesi bu yaklaşım nullifying dizisinin bir boşluk bırakır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="9acc4-184">Böylece alınması kayıtların kesin alt etkinleştirme satır dizini aracılığıyla, sayfa için verileri etkin bir şekilde ilişkilendirmek için kullanılan iki genel teknikler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="9acc4-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="9acc4-185">**SQL Server 2005 s kullanarak `ROW_NUMBER()` anahtar sözcüğü** SQL Server 2005, yeni `ROW_NUMBER()` anahtar sözcüğü bir derecelendirme sırasını bazı temel her döndürülen kayıtla ilişkilendirir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="9acc4-186">Bu derecelendirme her satır için bir satır dizini kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="9acc4-187">**Bir tablo değişkeni kullanarak ve `SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT` deyimi](https://msdn.microsoft.com/library/ms188774.aspx) sorguda işlem sonlandırmadan önce; toplam kayıt sayısını belirtmek için kullanılır [Tablo değişkenleri](http://www.sqlteam.com/item.asp?ItemID=9454) akin için tablo veri tutabilen yerel T-SQL değişkenleri [geçici tablolar](http://www.sqlteam.com/item.asp?ItemID=2029).</span><span class="sxs-lookup"><span data-stu-id="9acc4-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="9acc4-188">Bu yaklaşım eşit çalışır Microsoft SQL Server 2005 ve SQL Server 2000 ile (ancak `ROW_NUMBER()` yaklaşımı, yalnızca SQL Server 2005'te çalışır).</span><span class="sxs-lookup"><span data-stu-id="9acc4-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="9acc4-189">Buradaki sahip bir tablo değişkeni oluşturmaktır bir `IDENTITY` sütunu ve verileri disk belleği aracılığıyla tablosunun birincil anahtarlar için sütunları.</span><span class="sxs-lookup"><span data-stu-id="9acc4-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="9acc4-190">Ardından, verileri disk belleği aracılığıyla tablosunun içeriğini yazılan, böylece bir sıralı satır dizini ilişkilendirme tablo değişkenine (aracılığıyla `IDENTITY` sütun) tablosundaki her kayıt için.</span><span class="sxs-lookup"><span data-stu-id="9acc4-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="9acc4-191">Tablo değişkeni doldurulmuş sonra bir `SELECT` deyimi tablo değişkeni üzerinde temel alınan tabloda ile birleştirilmiş, belirli kayıtları çıkarmak için çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="9acc4-192">`SET ROWCOUNT` Deyimi akıllıca tablo değişkenine dökümünün gerek kayıt sayısını sınırlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="9acc4-193">Bu yaklaşım s verimliliği istenen, sayfa numarası dayalı olarak `SET ROWCOUNT` değeri Başlat satır dizini artı en fazla satır değeri atanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="9acc4-194">İlk gibi düşük numaralı sayfaları aracılığıyla veri birkaç sayfa sayfalama bu çok verimli bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="9acc4-195">Ancak, bir sayfa sonlarında alınırken varsayılan disk belleği benzeri performans sergiler.</span><span class="sxs-lookup"><span data-stu-id="9acc4-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="9acc4-196">Disk belleği özel kullanarak bu öğreticinin uygulayan `ROW_NUMBER()` anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="9acc4-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="9acc4-197">Tablo değişkeni kullanma hakkında daha fazla bilgi için ve `SET ROWCOUNT` teknik bkz [bir disk belleği aracılığıyla büyük sonuç kümeleri için daha fazla verimli yöntemi](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span><span class="sxs-lookup"><span data-stu-id="9acc4-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="9acc4-198">`ROW_NUMBER()` Anahtar sözcüğü bir belirli aşağıdaki sözdizimini kullanarak sıralama üzerinden döndürülen her kayıt sıralaması ilişkili:</span><span class="sxs-lookup"><span data-stu-id="9acc4-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

<span data-ttu-id="9acc4-199">`ROW_NUMBER()` belirtilen sıralama göre her bir kayıt için derecesini belirtir sayısal bir değer döndürür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="9acc4-200">Örneğin, en iyi sıralı her ürün için derecesini görmek için en az pahalı biz aşağıdaki sorguyu kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="9acc4-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

<span data-ttu-id="9acc4-201">Şekil 5 bu sorgu Visual Studio sorgu penceresinde aracılığıyla çalıştırdığınızda s sonuçları gösterir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="9acc4-202">Ürünleri fiyat, her satır için bir fiyat derece birlikte tarafından sıralanır unutmayın.</span><span class="sxs-lookup"><span data-stu-id="9acc4-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>


![Fiyat derecesini için dahil edilen her döndürülen kayıt](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

<span data-ttu-id="9acc4-204">**Şekil 5**: için fiyat derece dahil her döndürülen kayıt</span><span class="sxs-lookup"><span data-stu-id="9acc4-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>


> [!NOTE]
> <span data-ttu-id="9acc4-205">`ROW_NUMBER()` birçok yeni derecelendirme işlevleri yalnızca biri, SQL Server 2005'te kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="9acc4-206">Daha kapsamlı bir irdelemesi `ROW_NUMBER()`, diğer derecelendirme işlevler yanı sıra, okuma [Microsoft SQL Server 2005'te derece sonuçları döndüren](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span><span class="sxs-lookup"><span data-stu-id="9acc4-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>


<span data-ttu-id="9acc4-207">Sonuçları tarafından belirtilen sıralama zaman `ORDER BY` sütununda `OVER` yan tümcesi (`UnitPrice`, yukarıdaki örnekte), SQL Server sonuçlarını sıralama gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="9acc4-208">Bu sonuçları sipariş edilen tarafından sütunları üzerinden kümelenmiş bir dizin ise hızlı bir işlemdir veya bir kapsayıcı olup olmadığını dizin ancak Aksi halde daha pahalı olabilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="9acc4-209">Yardımcı olmak için yeterince büyük sorgular performansını olarak sonuçları göre sıralanmış sütun için bir kümelenmemiş dizin eklemeyi düşünün.</span><span class="sxs-lookup"><span data-stu-id="9acc4-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="9acc4-210">Bkz: [sıralaması işlevleri ve SQL Server 2005'te performans](http://www.sql-server-performance.com/ak_ranking_functions.asp) başarım düşünceleri daha ayrıntılı bir bakış için.</span><span class="sxs-lookup"><span data-stu-id="9acc4-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="9acc4-211">Tarafından döndürülen derecelendirme bilgi `ROW_NUMBER()` doğrudan kullanılamaz `WHERE` yan tümcesi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="9acc4-212">Ancak, türetilmiş tablo döndürmek için kullanılabilir `ROW_NUMBER()` ardından görüntülenebilir sonuç `WHERE` yan tümcesi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="9acc4-213">Örneğin, aşağıdaki sorguyu ile birlikte ProductName ve UnitPrice sütunlarını döndürmek için bir türetilmiş tablo kullanır `ROW_NUMBER()` sonucu ve kullandığı bir `WHERE` sadece bu ürünler, fiyat derece döndürmek için yan tümcesi olan 11 ile 20 arasında:</span><span class="sxs-lookup"><span data-stu-id="9acc4-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

<span data-ttu-id="9acc4-214">Bu kavram biraz daha fazla genişletme, belirli bir sayfayı istenen satır dizini başlatmak ve en fazla satır değerleri verilen veri almak için bu yaklaşım kullanabilir:</span><span class="sxs-lookup"><span data-stu-id="9acc4-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="9acc4-215">Bu öğreticide daha sonra göreceğiz gibi *`StartRowIndex`* tarafından sağlanan ObjectDataSource sıfırda, başlangıç ancak dizinlenir `ROW_NUMBER()` SQL Server 2005 tarafından döndürülen değer dizini 1'den başlayarak.</span><span class="sxs-lookup"><span data-stu-id="9acc4-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="9acc4-216">Bu nedenle, `WHERE` yan tümcesi döndürür kayıtların nerede `PriceRank` değerinden kesinlikle büyük olan *`StartRowIndex`* ve küçük veya eşit *`StartRowIndex`*  +  *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="9acc4-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>


<span data-ttu-id="9acc4-217">Şimdi görüyoruz nasıl ele alınan ve `ROW_NUMBER()` olabilir satır dizini başlatmak ve en fazla satır değerleri verilen verileri belirli bir sayfa almak için kullanılan, artık bu mantık DAL ve BLL yöntemleri olarak uygulamak ihtiyacımız.</span><span class="sxs-lookup"><span data-stu-id="9acc4-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="9acc4-218">Biz sıralama karar vermelisiniz bu sorguyu oluştururken kullanacağı sonuçları derece verilecek; ürünleri adı alfabetik sıralama s olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="9acc4-219">Bu, özel bir disk belleği uygulama Bu öğreticide biz de sıralanabilir daha özel bir disk belleğine alınan rapor oluşturabilmek için olmayacağını anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="9acc4-220">Sonraki öğreticide, ancak bu tür işlevselliği nasıl sağlanabilir göreceğiz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="9acc4-221">Önceki bölümde bir geçici SQL deyimi DAL yöntemi oluşturduk.</span><span class="sxs-lookup"><span data-stu-id="9acc4-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="9acc4-222">Ne yazık ki, T-SQL ayrıştırıcı Visual Studio'da gibi TableAdapter Sihirbazı mevcut değil t tarafından kullanılan `OVER` tarafından kullanılan sözdizimi `ROW_NUMBER()` işlevi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="9acc4-223">Bu nedenle, biz bu DAL yöntemi bir saklı yordam oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="9acc4-224">Sunucu Gezgini Görünüm menüsünde (veya isabet Ctrl + Alt + S) seçin ve genişletin `NORTHWND.MDF` düğümü.</span><span class="sxs-lookup"><span data-stu-id="9acc4-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="9acc4-225">Yeni bir saklı yordam eklemek için saklı yordamlar düğümüne sağ tıklayın ve yeni bir saklı yordam Ekle'yi seçin (bkz. Şekil 6).</span><span class="sxs-lookup"><span data-stu-id="9acc4-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>


![Sayfalama ürünleri aracılığıyla yeni bir saklı yordam ekleyin](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

<span data-ttu-id="9acc4-227">**Şekil 6**: sayfalama ürünleri aracılığıyla yeni bir saklı yordam ekleyin</span><span class="sxs-lookup"><span data-stu-id="9acc4-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>


<span data-ttu-id="9acc4-228">Bu saklı yordam iki tamsayı giriş parametreleri - kabul etmelidir `@startRowIndex` ve `@maximumRows` ve `ROW_NUMBER()` işlevi göre sıralayarak `ProductName` alan, yalnızca bu satırları büyük belirtilen döndüren `@startRowIndex` ve küçüktür veya eşit `@startRowIndex`  +  `@maximumRow` s.</span><span class="sxs-lookup"><span data-stu-id="9acc4-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="9acc4-229">Yeni bir saklı yordam aşağıdaki betiği girin ve ardından saklı yordamı veritabanına eklemek için Kaydet simgesine tıklayın.</span><span class="sxs-lookup"><span data-stu-id="9acc4-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

<span data-ttu-id="9acc4-230">Saklı yordam oluşturduktan sonra onu test etmek için bir dakikanızı ayırın. Sağ `GetProductsPaged` saklı yordam adı Server Explorer'da ve yürütme seçeneğini belirleyin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="9acc4-231">Visual Studio sonra sorar giriş parametreleri için `@startRowIndex` ve `@maximumRow` s (bkz. Şekil 7).</span><span class="sxs-lookup"><span data-stu-id="9acc4-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="9acc4-232">Farklı değerler deneyin ve sonuçları inceleyin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-232">Try different values and examine the results.</span></span>


![İçin bir değer girin @startRowIndex ve @maximumRows parametreleri](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<span data-ttu-id="9acc4-234"><strong>Şekil 7</strong>: için bir değer girin @startRowIndex ve @maximumRows parametreleri</span><span class="sxs-lookup"><span data-stu-id="9acc4-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>


<span data-ttu-id="9acc4-235">Sonra bu seçme giriş parametreleri değerleri, çıktı penceresinde sonuçları gösterilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="9acc4-236">Şekil 8, 10'da her ikisi için geçirilirken sonuçları gösterir `@startRowIndex` ve `@maximumRows` parametreleri.</span><span class="sxs-lookup"><span data-stu-id="9acc4-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>


<span data-ttu-id="9acc4-237">[![Kayıtları, görüneceği, ikinci sayfa veri döndürülür](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="9acc4-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span></span>

<span data-ttu-id="9acc4-238">**Şekil 8**: kayıtları olduğunu görüneceği, ikinci sayfa veri döndürülür ([tam boyutlu görüntüyü görüntülemek için tıklatın](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="9acc4-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span></span>


<span data-ttu-id="9acc4-239">Bu saklı oluşturulan yordamı biz oluşturmak için hazır re `ProductsTableAdapter` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="9acc4-240">Açık `Northwind.xsd` yazılan veri kümesi, sağ tıklatın `ProductsTableAdapter`ve Sorgu Ekle seçeneğini belirleyin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="9acc4-241">Geçici SQL deyimi kullanarak sorguyu oluşturmak yerine var olan bir saklı yordamı kullanarak oluşturun.</span><span class="sxs-lookup"><span data-stu-id="9acc4-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>


![Varolan bir saklı yordamı kullanarak DAL yöntemi oluşturma](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

<span data-ttu-id="9acc4-243">**Şekil 9**: varolan bir saklı yordamı kullanarak DAL yöntemi oluşturma</span><span class="sxs-lookup"><span data-stu-id="9acc4-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>


<span data-ttu-id="9acc4-244">Ardından, biz çağırmak için saklı yordam seçmeniz istenir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="9acc4-245">Çekme `GetProductsPaged` saklı yordamı aşağı açılan listeden.</span><span class="sxs-lookup"><span data-stu-id="9acc4-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>


![GetProductsPaged seçin saklı yordamı aşağı açılan listeden](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

<span data-ttu-id="9acc4-247">**Şekil 10**: GetProductsPaged seçin saklı yordamı aşağı açılan listeden</span><span class="sxs-lookup"><span data-stu-id="9acc4-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>


<span data-ttu-id="9acc4-248">Sonraki ekranda sonra ne tür veriler saklı yordam tarafından döndürülen ister: Tablo verileri, tek bir değer veya değer yok.</span><span class="sxs-lookup"><span data-stu-id="9acc4-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="9acc4-249">Bu yana `GetProductsPaged` saklı yordam birden çok kayıt iade, tablo veri döndürdüğünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>


![Saklı yordam tablo verisi döndüren belirtin](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

<span data-ttu-id="9acc4-251">**Şekil 11**: saklı yordamı tablo verisi döndüren belirtin</span><span class="sxs-lookup"><span data-stu-id="9acc4-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>


<span data-ttu-id="9acc4-252">Son olarak, oluşturduğunuz istediğiniz yöntemleri adlarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="9acc4-253">Önceki öğreticilerimizi gibi ile devam edin ve hem dolgusu kullanma yöntemleri DataTable oluşturma ve DataTable döndürür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="9acc4-254">İlk yöntem adı `FillPaged` ve ikinci `GetProductsPaged`.</span><span class="sxs-lookup"><span data-stu-id="9acc4-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>


![Ad yöntemleri FillPaged ve GetProductsPaged](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

<span data-ttu-id="9acc4-256">**Şekil 12**: ad yöntemleri FillPaged ve GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="9acc4-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>


<span data-ttu-id="9acc4-257">Ayrıca oluşturulan yönteme ürünlerin belirli bir sayfaya dönmek için DAL, biz de BLL böyle işlevindeki sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="9acc4-258">DAL yöntemi gibi BLL s GetProductsPaged yöntemi satır dizini başlatmak ve en fazla satır belirtmek için iki tamsayı girdi kabul etmeniz gerekir ve yalnızca belirtilen aralıkta kayıtları döndürmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="9acc4-259">Bu tür bir BLL yöntemi yalnızca çağrılarını aşağı DAL s GetProductsPaged yöntemi sözlüğüdür olduğunu ProductsBLL sınıfında oluşturun:</span><span class="sxs-lookup"><span data-stu-id="9acc4-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

<span data-ttu-id="9acc4-260">Herhangi bir ad kullanabilirsiniz BLL s yöntemi giriş parametreleri için ancak, kısa bir süre içinde göreceğiz olarak kullanmayı seçmeden `startRowIndex` ve `maximumRows` bize fazladan kaydeder bu yöntemi kullanmak için bir ObjectDataSource yapılandırırken iş bit.</span><span class="sxs-lookup"><span data-stu-id="9acc4-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="9acc4-261">4. adım: Özel sayfalama kullanacak biçimde ObjectDataSource yapılandırma</span><span class="sxs-lookup"><span data-stu-id="9acc4-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="9acc4-262">Belirli bir alt kayıtların tam erişim BLL ve DAL yöntemleri ile biz GridView oluşturmak için hazır re özel sayfalama kullanarak temel kayıtlarını bu sayfalarıyla denetler.</span><span class="sxs-lookup"><span data-stu-id="9acc4-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="9acc4-263">Başlangıç açarak `EfficientPaging.aspx` sayfasındaki `PagingAndSorting` klasörü, sayfaya GridView eklemek ve yeni ObjectDataSource Denetimi kullanacak şekilde yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="9acc4-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="9acc4-264">Son öğreticilerimizi biz genellikle kullanmak üzere yapılandırılmış ObjectDataSource vardı `ProductsBLL` s sınıfı `GetProducts` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="9acc4-265">Bu süre, ancak biz kullanmak istediğiniz `GetProductsPaged` yöntemi bunun yerine, bu yana `GetProducts` yöntemi döndürür *tüm* veritabanındaki ürünlerin ancak `GetProductsPaged` yalnızca belirli kayıtların bir alt kümesini döndürür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>


![ObjectDataSource s ProductsBLL sınıfı GetProductsPaged yöntemi kullanmak üzere yapılandırma](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

<span data-ttu-id="9acc4-267">**Şekil 13**: ObjectDataSource s ProductsBLL sınıfı GetProductsPaged yöntemi kullanmak üzere yapılandırma</span><span class="sxs-lookup"><span data-stu-id="9acc4-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>


<span data-ttu-id="9acc4-268">Biz salt okunur GridView oluşturma re itibaren INSERT, UPDATE, yöntem açılan listesi ayarlamak için bir dakikanızı ayırın ve sekmeleri (hiçbiri) SİLİN.</span><span class="sxs-lookup"><span data-stu-id="9acc4-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="9acc4-269">Ardından, ObjectDataSource Sihirbazı bize kaynakları için ister `GetProductsPaged` s yöntemi `startRowIndex` ve `maximumRows` giriş parametre değerleri.</span><span class="sxs-lookup"><span data-stu-id="9acc4-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="9acc4-270">Bu giriş parametreleri gerçekte GridView tarafından otomatik olarak ayarlanır, böylece yalnızca kaynak kümesi None olarak bırakın ve Son'u tıklatın.</span><span class="sxs-lookup"><span data-stu-id="9acc4-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>


![Giriş parametresi kaynakları hiçbiri olarak bırakın](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

<span data-ttu-id="9acc4-272">**Şekil 14**: giriş parametresi kaynakları hiçbiri olarak bırakın</span><span class="sxs-lookup"><span data-stu-id="9acc4-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>


<span data-ttu-id="9acc4-273">ObjectDataSource Sihirbazı'nı tamamladıktan sonra GridView BoundField veya CheckBoxField ürün veri alanların her biri için içerir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="9acc4-274">GridView s görünüm uygun gördüğünüz şekilde uyarlamak çekinmeyin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="9acc4-275">I ullanıcı seçti yalnızca görüntülenecek `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, ve `UnitPrice` BoundFields.</span><span class="sxs-lookup"><span data-stu-id="9acc4-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="9acc4-276">Ayrıca, disk belleği akıllı etiket sayfalama etkinleştir onay kutusunu işaretleyerek desteklemek için GridView yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="9acc4-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="9acc4-277">Bu değişikliklerden sonra GridView ve ObjectDataSource bildirim temelli biçimlendirme aşağıdakine benzer görünmelidir:</span><span class="sxs-lookup"><span data-stu-id="9acc4-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

<span data-ttu-id="9acc4-278">Bir tarayıcı aracılığıyla sayfasını ziyaret edin, ancak GridView hiçbir yerdir bulunma.</span><span class="sxs-lookup"><span data-stu-id="9acc4-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>


![GridView gösterilmez olduğu](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

<span data-ttu-id="9acc4-280">**Şekil 15**: GridView olduğu görüntülenmiyor</span><span class="sxs-lookup"><span data-stu-id="9acc4-280">**Figure 15**: The GridView is Not Displayed</span></span>


<span data-ttu-id="9acc4-281">ObjectDataSource şu anda 0 değerleri olarak her iki için kullandığından GridView eksik `GetProductsPaged` `startRowIndex` ve `maximumRows` giriş parametreleri.</span><span class="sxs-lookup"><span data-stu-id="9acc4-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="9acc4-282">Bu nedenle, sonuçta elde edilen SQL sorgu hiç kayıt döndürüyor ve bu nedenle GridView görüntülenmiyor.</span><span class="sxs-lookup"><span data-stu-id="9acc4-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="9acc4-283">Bu sorunu gidermek için şu ObjectDataSource özel disk belleği kullanacak şekilde yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="9acc4-284">Bu aşağıdaki adımlarda gerçekleştirilebilir:</span><span class="sxs-lookup"><span data-stu-id="9acc4-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="9acc4-285">**ObjectDataSource s ayarlamak `EnablePaging` özelliğine `true`**  bu geçmesi gereken ObjectDataSource gösterir `SelectMethod` iki ek parametreler: bir başlangıç satır dizini belirtmek için ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), diğeri en fazla satır belirtmek için ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span><span class="sxs-lookup"><span data-stu-id="9acc4-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="9acc4-286">**ObjectDataSource s ayarlamak `StartRowIndexParameterName` ve `MaximumRowsParameterName` uygun şekilde özellikleri** `StartRowIndexParameterName` ve `MaximumRowsParameterName` özellikleri içine geçirilen giriş parametreleri adlarını gösterir `SelectMethod` özel disk belleği amacıyla.</span><span class="sxs-lookup"><span data-stu-id="9acc4-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="9acc4-287">Varsayılan olarak, bu parametre adları olan `startIndexRow` ve `maximumRows`, neden, olduğu oluştururken `GetProductsPaged` yöntemi BLL bu değerleri giriş parametreleri için kullandım.</span><span class="sxs-lookup"><span data-stu-id="9acc4-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="9acc4-288">Farklı parametre adları BLL s için kullanmayı tercih `GetProductsPaged` yöntemi gibi `startIndex` ve `maxRows`gerekir örnek ObjectDataSource s ayarlamak için `StartRowIndexParameterName` ve `MaximumRowsParameterName` özellikleri buna göre (örneğin, startIndex için `StartRowIndexParameterName` ve maxRows için `MaximumRowsParameterName`).</span><span class="sxs-lookup"><span data-stu-id="9acc4-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="9acc4-289">**ObjectDataSource s ayarlamak [ `SelectCountMethod` özelliği](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) toplam sayı, kayıtları olan disk belleği aracılığıyla döndüren yöntemi adına (`TotalNumberOfProducts`)** sözcüğünün `ProductsBLL` s sınıfı`TotalNumberOfProducts`yöntemi döndürür yürüten bir DAL yöntemi kullanılarak üzerinden disk belleği kayıtlarının toplam sayısı bir `SELECT COUNT(*) FROM Products` sorgu.</span><span class="sxs-lookup"><span data-stu-id="9acc4-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="9acc4-290">Bu bilgiler ObjectDataSource tarafından doğru disk belleği arabirimini oluşturmak için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="9acc4-291">**Kaldırma `startRowIndex` ve `maximumRows` `<asp:Parameter>` ObjectDataSource s bildirim temelli biçimlendirme öğelerinden** Sihirbazı aracılığıyla ObjectDataSource yapılandırırken, Visual Studio otomatik olarak iki eklenen `<asp:Parameter>` öğeleri için `GetProductsPaged` s yöntemi giriş parametreleri.</span><span class="sxs-lookup"><span data-stu-id="9acc4-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="9acc4-292">Ayarlayarak `EnablePaging` için `true`, bu parametreleri otomatik olarak geçirilir; bunlar da bildirim temelli sözdiziminde görünüyorsa, ObjectDataSource geçirmek deneyecek *dört* parametreleri `GetProductsPaged` yöntemi ve iki parametre `TotalNumberOfProducts` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="9acc4-293">Bunlar kaldırmak unutursanız `<asp:Parameter>` gibi bir hata iletisi alacaksınız bir tarayıcı aracılığıyla sitesini ziyaret ettiğinde öğeleri: *ObjectDataSource 'ObjectDataSource1' genel olmayan yöntemi 'sahip TotalNumberOfProducts' bulamadı Parametreler: startRowIndex, maximumRows*.</span><span class="sxs-lookup"><span data-stu-id="9acc4-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="9acc4-294">Bu değişiklikleri yaptıktan sonra ObjectDataSource s tanımlayıcı sözdizimi aşağıdaki gibi görünmelidir:</span><span class="sxs-lookup"><span data-stu-id="9acc4-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

<span data-ttu-id="9acc4-295">Unutmayın `EnablePaging` ve `SelectCountMethod` özelliklerini ayarlamak ve `<asp:Parameter>` öğeler kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="9acc4-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="9acc4-296">Bu değişiklikler yapıldıktan sonra Şekil 16 penceresinin ekran görüntüsü gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>


![ObjectDataSource Denetimi özel sayfalama kullanacak biçimde yapılandırın](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

<span data-ttu-id="9acc4-298">**Şekil 16**: özel sayfalama kullanacak biçimde ObjectDataSource Denetimi yapılandırma</span><span class="sxs-lookup"><span data-stu-id="9acc4-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>


<span data-ttu-id="9acc4-299">Bu değişiklikleri yaptıktan sonra bir tarayıcı aracılığıyla bu sayfasını ziyaret edin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="9acc4-300">Listelenen, 10 ürünler görmelisiniz alfabetik sıraya göre.</span><span class="sxs-lookup"><span data-stu-id="9acc4-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="9acc4-301">Bir kerede bir sayfa veri adım için bir dakikanızı ayırın.</span><span class="sxs-lookup"><span data-stu-id="9acc4-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="9acc4-302">Son kullanıcı s perspektifinden görsel fark varsayılan disk belleği ve özel sayfalama arasında olsa da, yalnızca belirli bir sayfa için görüntülenecek gereken kayıtları alır gibi daha verimli bir şekilde özel disk belleği büyük miktarlarda verinin sayfaları.</span><span class="sxs-lookup"><span data-stu-id="9acc4-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>


<span data-ttu-id="9acc4-303">[![Veriler, sipariş edilmiş s adı, ürün tarafından olan disk belleği, kullanma, özel disk belleği](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="9acc4-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span></span>

<span data-ttu-id="9acc4-304">**Şekil 17**: verileri, sipariş edilmiş s adı, ürün tarafından olan disk belleği, kullanma, özel disk belleği ([tam boyutlu görüntüyü görüntülemek için tıklatın](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="9acc4-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span></span>


> [!NOTE]
> <span data-ttu-id="9acc4-305">Özel disk belleği ile sayfayı saymak ObjectDataSource s tarafından döndürülen değer `SelectCountMethod` GridView s görünüm durumuna depolanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="9acc4-306">Diğer GridView değişkenleri `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` koleksiyonu vb. depolanır *denetim durumu*, GridView s değerini bakılmaksızın kalıcı `EnableViewState` özellik.</span><span class="sxs-lookup"><span data-stu-id="9acc4-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="9acc4-307">Bu yana `PageCount` değeri kalıcıdır görünüm durumu, son sayfaya götüren bir bağlantı içeren bir disk belleği arabirimi kullanılırken kullanarak Geri göndermeler arasında GridView s Görünüm durumunun etkinleştirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="9acc4-308">(Disk belleği Arabiriminizin doğrudan bir bağlantı son içermiyorsa sayfa, Görünüm durumu devre dışı bırakabilir ardından.)</span><span class="sxs-lookup"><span data-stu-id="9acc4-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>


<span data-ttu-id="9acc4-309">Son sayfa bağlantısını tıklatarak geri gönderimin neden olur ve güncelleştirmek için GridView bildirir, `PageIndex` özelliği.</span><span class="sxs-lookup"><span data-stu-id="9acc4-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="9acc4-310">Son sayfayı bağlantıya tıkladıysanız GridView atar kendi `PageIndex` özelliğini bir değere değerinden kendi `PageCount` özelliği.</span><span class="sxs-lookup"><span data-stu-id="9acc4-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="9acc4-311">Devre dışı, Görünüm durumu ile `PageCount` değeri arasında Geri göndermeler kaybolur ve `PageIndex` en büyük tamsayı değeri yerine atanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="9acc4-312">Ardından, GridView çarparak başlangıç satır dizini belirlemeye çalışır `PageSize` ve `PageCount` özellikleri.</span><span class="sxs-lookup"><span data-stu-id="9acc4-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="9acc4-313">Bunun bir `OverflowException` ürün izin verilen en büyük tamsayı boyutu aştığından.</span><span class="sxs-lookup"><span data-stu-id="9acc4-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="9acc4-314">Uygulama özel sayfalama ve sıralama</span><span class="sxs-lookup"><span data-stu-id="9acc4-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="9acc4-315">Bizim geçerli özel disk belleği uygulaması oluştururken kullandığı veri disk belleği aracılığıyla sipariş statik olarak belirtilmesini gerektirir `GetProductsPaged` saklı yordamı.</span><span class="sxs-lookup"><span data-stu-id="9acc4-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="9acc4-316">Ancak, GridView s akıllı etiket etkinleştirmek disk belleği seçeneği yanı sıra sıralama etkinleştir onay kutusunu içeren ettiğiniz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="9acc4-317">Ne yazık ki, bizim geçerli bir özel disk belleği uygulama GridView sıralama desteği ekleme yalnızca veri şu anda görüntülenen sayfadaki kayıtları sıralanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="9acc4-318">Örneğin, disk belleği da destekler ve daha sonra azalan sırada, ürün adı bazında veri'nın ilk sayfasında görüntülerken sıralamak için GridView yapılandırırsanız, ürünleri sırasını 1 sayfasında ters.</span><span class="sxs-lookup"><span data-stu-id="9acc4-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="9acc4-319">Şekil 18 görüldüğü gibi etiket formu ilk ürün etiket formu alfabetik olarak gelen 71 diğer ürünler yoksayar ters alfabetik sırayla sıralarken gösterir; yalnızca ilk sayfasındaki kayıtları sıralama olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>


<span data-ttu-id="9acc4-320">[![Yalnızca veri gösterilen geçerli sayfada sıralanır](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="9acc4-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span></span>

<span data-ttu-id="9acc4-321">**Şekil 18**: yalnızca veri gösterilen geçerli sayfada sıralanır ([tam boyutlu görüntüyü görüntülemek için tıklatın](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="9acc4-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span></span>


<span data-ttu-id="9acc4-322">Sıralama verileri BLL s'den aldıktan sonra oluşturduğumuzdan sıralama yalnızca geçerli sayfasına veri uygulanır `GetProductsPaged` yöntemi ve bu yöntem yalnızca belirli sayfa için kayıtları döndürür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="9acc4-323">Doğru sıralama uygulamak için sıralama ifadesi geçirmek ihtiyacımız `GetProductsPaged` yöntemi böylece veriler belirli sayfa veri göndermeden önce uygun şekilde sıralanabilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="9acc4-324">Bu bizim sonraki öğreticide gerçekleştirmek nasıl göreceğiz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="9acc4-325">Disk belleği ve silme özel uygulama</span><span class="sxs-lookup"><span data-stu-id="9acc4-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="9acc4-326">Veri disk belleği bulacaksınız, son sayfasından son kaydı silinirken özel disk belleği teknikler kullanılarak GridView içinde silme işlevini etkinleştirme GridView uygun şekilde azaltma yerine GridView s kaybolur,`PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="9acc4-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="9acc4-327">Bu hata yeniden oluşturmak için yalnızca yeni oluşturduğumuz öğretici için silme etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="9acc4-328">Burada size 81 ürünler, aynı anda 10 ürün üzerinden disk belleği bu yana tek bir ürün görmeniz gerekir (sayfa 9), son sayfasına gidin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="9acc4-329">Bu ürün silin.</span><span class="sxs-lookup"><span data-stu-id="9acc4-329">Delete this product.</span></span>

<span data-ttu-id="9acc4-330">GridView son ürün silme bağlı *gereken* otomatik olarak sekizinci sayfasına gidin ve bu tür işlevselliği varsayılan disk belleği ile sergilenen.</span><span class="sxs-lookup"><span data-stu-id="9acc4-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="9acc4-331">Özel disk belleği ile ancak son sayfasında, son bu ürünü sildikten sonra GridView yalnızca ekranından tamamen kaybolur.</span><span class="sxs-lookup"><span data-stu-id="9acc4-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="9acc4-332">Kesin neden *neden* bu biraz Bu öğretici kapsamında oluşur; bkz [GridView özel disk belleği ile son sayfasındaki son kayıt silmeye](http://scottonwriting.net/sowblog/posts/7326.aspx) kaynakla alt düzey ayrıntılar için Bu sorun.</span><span class="sxs-lookup"><span data-stu-id="9acc4-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="9acc4-333">Özet olarak, aşağıdaki Sil düğmesine tıklandığında, GridView tarafından gerçekleştirilen adımlar dizisini nedeniyle s:</span><span class="sxs-lookup"><span data-stu-id="9acc4-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="9acc4-334">Kaydını sil</span><span class="sxs-lookup"><span data-stu-id="9acc4-334">Delete the record</span></span>
2. <span data-ttu-id="9acc4-335">Belirtilen görüntülemek için uygun kayıtların tamamını `PageIndex` ve `PageSize`</span><span class="sxs-lookup"><span data-stu-id="9acc4-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="9acc4-336">Emin olmak için onay `PageIndex` otomatik olarak GridView s azaltma varsa, veri kaynağındaki; sayfaların sayısını aşmadığından `PageIndex` özelliği</span><span class="sxs-lookup"><span data-stu-id="9acc4-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="9acc4-337">2. adımda elde edilen kayıtları kullanarak GridView veri uygun sayfaya bağlamak</span><span class="sxs-lookup"><span data-stu-id="9acc4-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="9acc4-338">Sorunun zorluk ortaya söz konusu adım 2 kaynaklandığını `PageIndex` görüntülenecek kayıt kapmasını hala olduğunda kullanılan `PageIndex` son sayfasının tek kaydını yalnızca silindi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="9acc4-339">Bu nedenle, adım 2'deki *hiçbir* kayıtları veri son bu sayfayı artık herhangi bir kayıt içerdiğinden döndürülür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="9acc4-340">Sonra adım 3'te GridView, gerçekleştirir, `PageIndex` özellik sayfaları veri kaynağındaki toplam sayısından daha (biz bu yana ve son sayfasındaki son kaydı silinir) ve bu nedenle azaltır, `PageIndex` özelliği.</span><span class="sxs-lookup"><span data-stu-id="9acc4-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="9acc4-341">Adım 4'te GridView kendisini 2. adımda alınan veri bağlamak çalışır; Ancak, hiçbir kaydı döndürülmedi 2. adımda, bu nedenle boş bir GridView elde edilmesidir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="9acc4-342">Varsayılan disk belleği ile bu sorunu içermiyor t yüzey çünkü adım 2'deki *tüm* kayıtları, veri kaynağından alınır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="9acc4-343">Bu sorunu gidermek için şu iki seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-343">To fix this we have two options.</span></span> <span data-ttu-id="9acc4-344">İlk GridView s için bir olay işleyicisi oluşturmaktır `RowDeleted` kaç kayıtları yalnızca silindi sayfasında görüntülenen her belirler olay işleyicisi.</span><span class="sxs-lookup"><span data-stu-id="9acc4-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="9acc4-345">Yalnızca tek bir kayıt vardı sonra silinen kaydı sonuncu verilmiş olması gerekir ve GridView s düşürmek ihtiyacımız `PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="9acc4-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="9acc4-346">Elbette, yalnızca güncelleştirme istiyoruz `PageIndex` silme işlemi gerçekte başarılı olduysa, hangi belirlenebilir, sağlayarak `e.Exception` özelliği `null`.</span><span class="sxs-lookup"><span data-stu-id="9acc4-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="9acc4-347">Bu yaklaşım, güncelleştirdiğinden çalışır `PageIndex` 1. adım sonra ancak 2. adım önce.</span><span class="sxs-lookup"><span data-stu-id="9acc4-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="9acc4-348">Bu nedenle, adım 2'de uygun kayıt kümesi döndürülür.</span><span class="sxs-lookup"><span data-stu-id="9acc4-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="9acc4-349">Bunu başarmak için aşağıdaki gibi bir kod kullanın:</span><span class="sxs-lookup"><span data-stu-id="9acc4-349">To accomplish this, use code like the following:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

<span data-ttu-id="9acc4-350">Alternatif bir geçici çözüm ObjectDataSource s için bir olay işleyicisi oluşturmaktır `RowDeleted` olay ve ayarlamak için `AffectedRows` için 1 değerini özelliği.</span><span class="sxs-lookup"><span data-stu-id="9acc4-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="9acc4-351">1. adımda (ancak adım 2'deki verileri yeniden alma önce) kaydını sildikten sonra GridView güncelleştirmeleri kendi `PageIndex` bir veya daha fazla satır işlem tarafından etkilenen varsa özelliği.</span><span class="sxs-lookup"><span data-stu-id="9acc4-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="9acc4-352">Ancak, `AffectedRows` ObjectDataSource tarafından özelliği ayarlı değil ve bu nedenle bu adım atlanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="9acc4-353">Yürütülen Bu adım için bir yol olduğundan el ile ayarlamak için `AffectedRows` silme işlemi başarıyla tamamlarsa özelliği.</span><span class="sxs-lookup"><span data-stu-id="9acc4-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="9acc4-354">Bu, aşağıdaki gibi kod kullanarak gerçekleştirilebilir:</span><span class="sxs-lookup"><span data-stu-id="9acc4-354">This can be accomplished using code like the following:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

<span data-ttu-id="9acc4-355">Bu olay işleyicilerini her ikisi de kodunu arka plan kodu sınıfında bulunabilir `EfficientPaging.aspx` örnek.</span><span class="sxs-lookup"><span data-stu-id="9acc4-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="9acc4-356">Varsayılan ve özel disk belleği performans karşılaştırma</span><span class="sxs-lookup"><span data-stu-id="9acc4-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="9acc4-357">Varsayılan disk belleği verir kullanılabilirken özel sayfalama yalnızca gereken kayıtları alır beri *tüm* görüntülenmesini, her bir sayfa için kayıt, s temizleyin özel sayfalama varsayılan disk belleği değerinden daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="9acc4-358">Ancak özel sayfalama ne kadar daha verimli olur?</span><span class="sxs-lookup"><span data-stu-id="9acc4-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="9acc4-359">Ne tür bir performans kazancı özel disk belleği için varsayılan disk belleği'nden taşıyarak görülebilir mi?</span><span class="sxs-lookup"><span data-stu-id="9acc4-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="9acc4-360">Ne yazık ki, tek bir boyut var. s uyan tüm yanıt burada.</span><span class="sxs-lookup"><span data-stu-id="9acc4-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="9acc4-361">Performans kazancı bir dizi etkene bağlıdır, en belirgin iki aracılığıyla havuzda kaydeder ve yük sayısı olan web sunucusu ve veritabanı sunucusu arasındaki veritabanı sunucusu ve iletişim kanalları eklenir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="9acc4-362">Yalnızca birkaç düzine kayıtlarla küçük tablolar için bir performans farkı durum göz ardı edilebilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="9acc4-363">Yüz binlerce satır binlerce ile büyük tablolar için yine de performans acute farktır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="9acc4-364">Benim, bir makalenin [ASP.NET 2. 0'sql Server 2005'te özel sayfalama](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), çalıştırdım performans ile bir veritabanı tablosu aracılığıyla sayfalama bu iki disk belleği teknikler arasındaki farklılıkları göstermesi için bazı performans testleri içerir 50.000 kaydeder.</span><span class="sxs-lookup"><span data-stu-id="9acc4-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="9acc4-365">Bu sınamalarda t SQL sunucu düzeyinde sorguyu yürütmek için her iki saat incelenmesi (kullanarak [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) ve ASP.NET sayfası kullanarak [ASP.NET s izleme özellikleri](https://msdn.microsoft.com/library/y13fw6we.aspx).</span><span class="sxs-lookup"><span data-stu-id="9acc4-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="9acc4-366">Bu testler tek bir etkin kullanıcı my geliştirme kutusuyla çalıştırmak olan ve bu nedenle Bilimsel olmayan ve tipik Web sitesi yük desenlerini taklit değil olduğunu göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="9acc4-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="9acc4-367">Ne olursa olsun, sonuçları yeterince büyük miktarlarda veri çalışırken varsayılan ve özel sayfalama için yürütme süresi göreli farklar gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>


|  | <span data-ttu-id="9acc4-368">**Ort. Süresi (saniye)**</span><span class="sxs-lookup"><span data-stu-id="9acc4-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="9acc4-369">**Okur**</span><span class="sxs-lookup"><span data-stu-id="9acc4-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="9acc4-370">**Varsayılan disk belleği SQL Profil Oluşturucu**</span><span class="sxs-lookup"><span data-stu-id="9acc4-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="9acc4-371">1.411</span><span class="sxs-lookup"><span data-stu-id="9acc4-371">1.411</span></span> | <span data-ttu-id="9acc4-372">383</span><span class="sxs-lookup"><span data-stu-id="9acc4-372">383</span></span> |
| <span data-ttu-id="9acc4-373">**Özel disk belleği SQL Profil Oluşturucu**</span><span class="sxs-lookup"><span data-stu-id="9acc4-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="9acc4-374">0.002</span><span class="sxs-lookup"><span data-stu-id="9acc4-374">0.002</span></span> | <span data-ttu-id="9acc4-375">29</span><span class="sxs-lookup"><span data-stu-id="9acc4-375">29</span></span> |
| <span data-ttu-id="9acc4-376">**Varsayılan disk belleği ASP.NET izleme**</span><span class="sxs-lookup"><span data-stu-id="9acc4-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="9acc4-377">2.379</span><span class="sxs-lookup"><span data-stu-id="9acc4-377">2.379</span></span> | <span data-ttu-id="9acc4-378">*YOK*</span><span class="sxs-lookup"><span data-stu-id="9acc4-378">*N/A*</span></span> |
| <span data-ttu-id="9acc4-379">**Özel sayfalama ASP.NET izleme**</span><span class="sxs-lookup"><span data-stu-id="9acc4-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="9acc4-380">0.029</span><span class="sxs-lookup"><span data-stu-id="9acc4-380">0.029</span></span> | <span data-ttu-id="9acc4-381">*YOK*</span><span class="sxs-lookup"><span data-stu-id="9acc4-381">*N/A*</span></span> |


<span data-ttu-id="9acc4-382">Gördüğünüz gibi verilerin belirli bir sayfa okuma daha az 354 ortalama gerekli ve alma süresi bir kısmı tamamlandı.</span><span class="sxs-lookup"><span data-stu-id="9acc4-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="9acc4-383">ASP.NET sayfasında, özel sayfa 1/100 yakın işlenecek kurtararak<sup>th</sup> saati varsayılan disk belleği kullanırken sürdü.</span><span class="sxs-lookup"><span data-stu-id="9acc4-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="9acc4-384">Bkz: [my makale](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) kodu ve bir veritabanı ile birlikte bu sonuçlar hakkında daha fazla bilgi için bu testleri kendi ortamınızda yeniden yükleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="9acc4-385">Özet</span><span class="sxs-lookup"><span data-stu-id="9acc4-385">Summary</span></span>

<span data-ttu-id="9acc4-386">Yalnızca onay sayfalama etkinleştir onay kutusunu veri Web denetim s akıllı etiketi içinde uygulamak için bağlamayı varsayılan disk belleği olan ancak bu tür Basitlik performans artırılabilir gelir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="9acc4-387">Kullanıcı verilerinin herhangi bir sayfayı istediğinde varsayılan disk belleği ile *tüm* kayıtları döndürüldü, yalnızca küçük bir kesir bunların gösterilen olsa bile.</span><span class="sxs-lookup"><span data-stu-id="9acc4-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="9acc4-388">Bu performans yükünü mücadele etmek için alternatif bir disk belleği seçeneği özel sayfalama ObjectDataSource sunar.</span><span class="sxs-lookup"><span data-stu-id="9acc4-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="9acc4-389">S performans sorunlarını görüntülenmesi gereken kayıtları alarak disk belleği varsayılan bağlı özel sayfalama artırır ancak, özel sayfalama uygulamak daha karmaşık s.</span><span class="sxs-lookup"><span data-stu-id="9acc4-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="9acc4-390">İlk olarak, bir sorgu, doğru (etkin) istenen kayıtların belirli alt erişir ve yazılmış olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="9acc4-391">Bu çeşitli şekillerde gerçekleştirilebilir; Biz bu öğreticide incelenmesi bir SQL Server 2005 s yeni kullanmaktır `ROW_NUMBER()` derece işleve sonuçları ve ardından yalnızca döndürülecek belirli bir aralıkta, derecelendirme döner sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="9acc4-392">Ayrıca, biz aracılığıyla havuzda kayıtlarının toplam sayısını belirlemek için bir yol eklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="9acc4-393">Bu DAL ve BLL yöntemleri oluşturduktan sonra biz de kaç toplam kayıt aracılığıyla havuzda ve satır dizini başlatmak ve en fazla satır değerleri BLL doğru geçirebilirsiniz belirleyebilmesi ObjectDataSource yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="9acc4-394">Özel disk belleği uygulama birkaç adımı gerektirir ve varsayılan disk belleği olarak değil neredeyse kadar basittir olsa da, özel disk belleği ile yeteri kadar büyük miktarlarda verinin sayfalama reddedilir.</span><span class="sxs-lookup"><span data-stu-id="9acc4-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="9acc4-395">Sonuçları incelenmesi olarak gösterilen, özel disk belleği saniye ASP.NET sayfası işleme süresi dışına shed ve veritabanı sunucusu üzerindeki yükü tarafından bir veya daha fazla büyüklük rengini açabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9acc4-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="9acc4-396">Mutluluk programlama!</span><span class="sxs-lookup"><span data-stu-id="9acc4-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="9acc4-397">Yazar hakkında</span><span class="sxs-lookup"><span data-stu-id="9acc4-397">About the Author</span></span>

<span data-ttu-id="9acc4-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), yazar ve yedi ASP/ASP.NET books kurucusu, [4GuysFromRolla.com](http://www.4guysfromrolla.com), Microsoft Web teknolojileri ile bu yana 1998 çalışma.</span><span class="sxs-lookup"><span data-stu-id="9acc4-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="9acc4-399">Tan bağımsız Danışman, eğitmen ve yazıcı çalışır.</span><span class="sxs-lookup"><span data-stu-id="9acc4-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="9acc4-400">En son kendi defteri [ *kendi öğretmek kendiniz ASP.NET 2.0 24 saat içindeki*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="9acc4-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="9acc4-401">Kendisi üzerinde erişilebilir [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) veya kendi blog hangi adresinde bulunabilir [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="9acc4-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="9acc4-402">[Önceki](paging-and-sorting-report-data-cs.md)
> [sonraki](sorting-custom-paged-data-cs.md)</span><span class="sxs-lookup"><span data-stu-id="9acc4-402">[Previous](paging-and-sorting-report-data-cs.md)
[Next](sorting-custom-paged-data-cs.md)</span></span>
