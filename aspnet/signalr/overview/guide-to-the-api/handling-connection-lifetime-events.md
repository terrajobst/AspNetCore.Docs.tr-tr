---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: "Anlama ve SignalR bağlantısı ömrü olayları işleme | Microsoft Docs"
author: pfletcher
description: "Bu makalede, hub API'si tarafından kullanıma sunulan olayları kullanmayı açıklar."
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2014
ms.topic: article
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 2fd9cafd8d7706807998793c3c39377fe9604266
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/24/2018
---
<a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="e6b45-103">Anlama ve SignalR bağlantısı ömrü olayları işleme</span><span class="sxs-lookup"><span data-stu-id="e6b45-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>
====================
<span data-ttu-id="e6b45-104">tarafından [CAN Fletcher'dan](https://github.com/pfletcher), [zel Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="e6b45-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="e6b45-105">Bu makalede işleyebilir SignalR bağlantısı, yeniden bağlanma ve bağlantıyı kesme olayları ve yapılandırabileceğiniz zaman aşımı ve canlı tutma ayarlarını genel bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6b45-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
> 
> <span data-ttu-id="e6b45-106">Makalede zaten SignalR ve bağlantı ömür olayları bazı bilgiye sahip olduğunuz varsayılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="e6b45-107">SignalR giriş için bkz: [SignalR giriş](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="e6b45-107">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="e6b45-108">Bağlantı ömrü olaylarının bir listesi için aşağıdaki kaynaklara bakın:</span><span class="sxs-lookup"><span data-stu-id="e6b45-108">For lists of connection lifetime events, see the following resources:</span></span>
> 
> - [<span data-ttu-id="e6b45-109">Bağlantı ömür olayları Hub sınıfında nasıl ele alınacağını</span><span class="sxs-lookup"><span data-stu-id="e6b45-109">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="e6b45-110">Bağlantı ömür olayları JavaScript istemcilerinin nasıl ele alınacağını</span><span class="sxs-lookup"><span data-stu-id="e6b45-110">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="e6b45-111">Bağlantı ömür olayları .NET istemcileri nasıl ele alınacağını</span><span class="sxs-lookup"><span data-stu-id="e6b45-111">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
> 
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="e6b45-112">Bu konuda kullanılan yazılım sürümleri</span><span class="sxs-lookup"><span data-stu-id="e6b45-112">Software versions used in this topic</span></span>
> 
> 
> - [<span data-ttu-id="e6b45-113">Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="e6b45-113">Visual Studio 2013</span></span>](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - <span data-ttu-id="e6b45-114">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="e6b45-114">.NET 4.5</span></span>
> - <span data-ttu-id="e6b45-115">SignalR sürüm 2</span><span class="sxs-lookup"><span data-stu-id="e6b45-115">SignalR version 2</span></span>
>   
> 
> 
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="e6b45-116">Bu konunun önceki sürümleri</span><span class="sxs-lookup"><span data-stu-id="e6b45-116">Previous versions of this topic</span></span>
> 
> <span data-ttu-id="e6b45-117">SignalR daha önceki sürümleri hakkında daha fazla bilgi için bkz: [SignalR eski sürümleri](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="e6b45-117">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="e6b45-118">Sorularınız ve yorumlarınız</span><span class="sxs-lookup"><span data-stu-id="e6b45-118">Questions and comments</span></span>
> 
> <span data-ttu-id="e6b45-119">Lütfen Bu öğretici beğendiğinizi nasıl ve ne biz sayfanın sonundaki açıklamalarında artabileceğini görüşlerinizi.</span><span class="sxs-lookup"><span data-stu-id="e6b45-119">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="e6b45-120">Öğretici için doğrudan ilgili olmayan sorularınız varsa, bunları nakledebilirsiniz [ASP.NET SignalR Forumu](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) veya [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="e6b45-120">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>


## <a name="overview"></a><span data-ttu-id="e6b45-121">Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="e6b45-121">Overview</span></span>

<span data-ttu-id="e6b45-122">Bu makalede aşağıdaki bölümleri içerir:</span><span class="sxs-lookup"><span data-stu-id="e6b45-122">This article contains the following sections:</span></span>

- [<span data-ttu-id="e6b45-123">Bağlantı ömrü terminoloji ve senaryolar</span><span class="sxs-lookup"><span data-stu-id="e6b45-123">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="e6b45-124">SignalR bağlantıları, aktarım bağlantıları ve fiziksel bağlantıları</span><span class="sxs-lookup"><span data-stu-id="e6b45-124">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="e6b45-125">Taşıma bağlantısı kesme senaryoları</span><span class="sxs-lookup"><span data-stu-id="e6b45-125">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="e6b45-126">İstemci bağlantısının kesilmesine senaryoları</span><span class="sxs-lookup"><span data-stu-id="e6b45-126">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="e6b45-127">Sunucu bağlantı kesme senaryoları</span><span class="sxs-lookup"><span data-stu-id="e6b45-127">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="e6b45-128">Zaman aşımı ve canlı tutma ayarları</span><span class="sxs-lookup"><span data-stu-id="e6b45-128">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="e6b45-129">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="e6b45-129">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="e6b45-130">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="e6b45-130">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="e6b45-131">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="e6b45-131">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="e6b45-132">Zaman aşımı ve canlı tutma ayarlarını değiştirme</span><span class="sxs-lookup"><span data-stu-id="e6b45-132">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="e6b45-133">Bağlantı kesilmeleri hakkında kullanıcıya bildirim nasıl</span><span class="sxs-lookup"><span data-stu-id="e6b45-133">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="e6b45-134">Sürekli olarak yeniden bağlama</span><span class="sxs-lookup"><span data-stu-id="e6b45-134">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="e6b45-135">Bir istemci sunucu kodunda kesme hakkında</span><span class="sxs-lookup"><span data-stu-id="e6b45-135">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="e6b45-136">Bağlantı kesme nedeni algılama</span><span class="sxs-lookup"><span data-stu-id="e6b45-136">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="e6b45-137">API başvuru konuları API'si .NET 4.5 sürümüne bağlantılardır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-137">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="e6b45-138">.NET 4 kullanıyorsanız, bkz: [API konuları .NET 4 sürümü](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="e6b45-138">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="e6b45-139">Bağlantı ömrü terminoloji ve senaryolar</span><span class="sxs-lookup"><span data-stu-id="e6b45-139">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="e6b45-140">`OnReconnected` Bir SignalR hub'ı olay işleyicisini hemen sonra yürütebilir `OnConnected` ancak sonra değil `OnDisconnected` belirtilen istemci için.</span><span class="sxs-lookup"><span data-stu-id="e6b45-140">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="e6b45-141">Bağlantı kesme olmadan yeniden bağlanmayı olabilir "bağlantı" word SignalR öğesinde kullanılan birkaç yolu vardır nedenidir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-141">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="e6b45-142">SignalR bağlantıları, aktarım bağlantıları ve fiziksel bağlantıları</span><span class="sxs-lookup"><span data-stu-id="e6b45-142">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="e6b45-143">Bu makalede birbirinden *SignalR bağlantıları*, *taşıma bağlantıları*, ve *fiziksel bağlantıları*:</span><span class="sxs-lookup"><span data-stu-id="e6b45-143">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="e6b45-144">**Bir SignalR bağlantısı** bir istemci ve sunucu URL'si, SignalR API'si tarafından korunur ve benzersiz bir bağlantı kimliği ile tanımlanan arasında mantıksal bir ilişki başvurur</span><span class="sxs-lookup"><span data-stu-id="e6b45-144">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="e6b45-145">Bu ilişki hakkındaki verileri SignalR tarafından korunur ve aktarım bağlantı kurmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-145">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="e6b45-146">İlişki Uçları ve SignalR istemci çağırdığında verilerini siler `Stop` yöntemi ve bir zaman aşımı sınırı SignalR kayıp aktarım yeniden bağlantı girişimi sırasında ulaşıldığında.</span><span class="sxs-lookup"><span data-stu-id="e6b45-146">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="e6b45-147">**Taşıma bağlantısı** dört aktarım API'lerini biri tarafından korunan bir sunucu ile istemci arasındaki mantıksal ilişkisi başvuruyor: WebSockets, sunucu tarafından gönderilen olayları, geri getirilemeyecek biçimde çerçeve veya uzun yoklama.</span><span class="sxs-lookup"><span data-stu-id="e6b45-147">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="e6b45-148">Taşıma bağlantısı oluşturmak için Aktarım API SignalR kullanır ve aktarım bağlantı oluşturmak için bir fiziksel ağ bağlantı varlığını aktarım API bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-148">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="e6b45-149">SignalR sonlandırıldığında veya API taşıma fiziksel bağlantı kesildiğinde algıladığında taşıma bağlantısını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-149">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="e6b45-150">**Fiziksel bağlantı** --kablo, fiziksel ağ bağlantıları kablosuz sinyalleri, yönlendiriciler, istemci bilgisayar ve bir sunucu bilgisayar arasındaki iletişimi kolaylaştırmak vb.--başvuruyor.</span><span class="sxs-lookup"><span data-stu-id="e6b45-150">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="e6b45-151">Fiziksel bağlantı taşıma bağlantısı kurabilmek için mevcut olması gerekir ve bir SignalR bağlantısı kurabilmek için taşıma bağlantı kurulamıyor.</span><span class="sxs-lookup"><span data-stu-id="e6b45-151">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="e6b45-152">Bu konunun ilerleyen bölümlerinde açıklandığı gibi ancak fiziksel bağlantısı kesiliyor her zaman hemen taşıma veya SignalR bağlantısı sonlanmıyor.</span><span class="sxs-lookup"><span data-stu-id="e6b45-152">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="e6b45-153">Aşağıdaki diyagramda bir SignalR bağlantısı PersistentConnection API SignalR katman ve hub API tarafından temsil edilen, Aktarım katmanı bağlantısı taşımaları katmanı tarafından temsil edilen ve fiziksel bağlantı sunucusu arasındaki çizgilerle gösterilir ve istemciler.</span><span class="sxs-lookup"><span data-stu-id="e6b45-153">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR mimarisi diyagramı](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="e6b45-155">Çağırdığınızda `Start` yöntemi SignalR İstemcisi'nde, sağlamayla SignalR istemci kodu fiziksel bir sunucuya bağlantı kurmak için gereken tüm bilgileri.</span><span class="sxs-lookup"><span data-stu-id="e6b45-155">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="e6b45-156">SignalR istemci kodu, bir HTTP isteği yapmak ve dört taşıma yöntemleri birini kullanan fiziksel bir ağ bağlantısı kurmak için bu bilgileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-156">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="e6b45-157">İstemci hala otomatik olarak yeni bir aktarım bağlantı SignalR URL'ye yeniden oluşturmak için gereken bilgileri içerdiğinden taşıma bağlantısı başarısız veya sunucu başarısız olursa bir SignalR bağlantısı hemen azalttıktan değil.</span><span class="sxs-lookup"><span data-stu-id="e6b45-157">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="e6b45-158">Bu senaryoda, kullanıcı uygulamasından herhangi bir müdahalesi söz konusu ve SignalR istemci kodu yeni bir aktarım bağlantı kurduğunda, yeni bir SignalR bağlantı başlatılmaz.</span><span class="sxs-lookup"><span data-stu-id="e6b45-158">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="e6b45-159">Bir SignalR bağlantısı sürekliliği aslında yansıtılır, çağırdığınızda oluşturulan bağlantı kimliği `Start` yöntemi, değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="e6b45-159">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="e6b45-160">`OnReconnected` Olay işleyicisi Hub'ında taşıma bağlantısı kesilmiş sonra otomatik olarak yeniden kurulduğunda yürütür.</span><span class="sxs-lookup"><span data-stu-id="e6b45-160">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="e6b45-161">`OnDisconnected` Olay işleyicisi bir SignalR bağlantısı sonunda yürütür.</span><span class="sxs-lookup"><span data-stu-id="e6b45-161">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="e6b45-162">Bir SignalR bağlantısı aşağıdaki yollardan biriyle sona erdirilebilir:</span><span class="sxs-lookup"><span data-stu-id="e6b45-162">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="e6b45-163">İstemci çağırırsa `Stop` yöntemi, bir Dur iletisi sunucuya gönderilir ve istemci ve sunucunun son bir SignalR bağlantısı hemen.</span><span class="sxs-lookup"><span data-stu-id="e6b45-163">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="e6b45-164">İstemci ve sunucu arasında bağlantı kaybedildikten sonra istemci yeniden bağlanmayı dener ve istemci yeniden bağlanmayı sunucu bekler.</span><span class="sxs-lookup"><span data-stu-id="e6b45-164">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="e6b45-165">Yeniden bağlanma girişimleri başarısız olur ve bağlantı kesme zaman aşımı süresi sona erer, istemci ve sunucu bir SignalR bağlantısı bitiş.</span><span class="sxs-lookup"><span data-stu-id="e6b45-165">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="e6b45-166">İstemci yeniden bağlanmayı denemeden durdurur ve sunucunun kendi SignalR bağlantısı gösterimi siler.</span><span class="sxs-lookup"><span data-stu-id="e6b45-166">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="e6b45-167">İstemci çağırmak için bir fırsat gerek kalmadan çalıştıran durduğunda `Stop` yöntemi, sunucunun beklediği istemci yeniden bağlanmak ve sonra bağlantı kesme zaman aşımı süresinden sonra da SignalR bağlantıyı sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-167">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="e6b45-168">Çalıştıran, sunucusu vermiyor bağlanmayı istemci çalışır (taşıma bağlantısını yeniden oluşturursanız) ve sonra bağlantı kesme zaman aşımı süresinden sonra da SignalR bağlantıyı sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-168">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="e6b45-169">Ne zaman bağlantı sorunu olmadığından ve çağırarak kullanıcı uygulaması SignalR bağlantısı sona erer `Stop` yöntemi, bir SignalR bağlantısı ve aktarım bağlantı başlar ve aynı anda hakkında son adresindeki.</span><span class="sxs-lookup"><span data-stu-id="e6b45-169">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="e6b45-170">Aşağıdaki bölümlerde daha ayrıntılı olarak diğer senaryolar açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-170">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="e6b45-171">Taşıma bağlantısı kesme senaryoları</span><span class="sxs-lookup"><span data-stu-id="e6b45-171">Transport disconnection scenarios</span></span>

<span data-ttu-id="e6b45-172">Fiziksel bağlantı yavaş olabilir veya bağlantı kesintiler olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-172">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="e6b45-173">Taşıma bağlantısı kesinti uzunluğu gibi etkenlere bağlı olarak bırakılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-173">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="e6b45-174">SignalR sonra aktarım yeniden bağlantı kurmayı dener.</span><span class="sxs-lookup"><span data-stu-id="e6b45-174">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="e6b45-175">Bazen taşıma bağlantısı API kesinti algılar ve taşıma bağlantısını keser ve SignalR hemen bağlantısı kesildiği öğrenir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-175">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="e6b45-176">Diğer senaryolarda ne taşıma bağlantısı API ne de SignalR hemen bağlantısı kaybedildi uyumlu olur.</span><span class="sxs-lookup"><span data-stu-id="e6b45-176">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="e6b45-177">Uzun yoklama dışındaki tüm taşımaları için SignalR istemcisi adlı bir işlev kullanan *keepalive* API taşıma algılayamıyor bağlantı kaybı için denetlemek için.</span><span class="sxs-lookup"><span data-stu-id="e6b45-177">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="e6b45-178">Uzun yoklama bağlantılar hakkında daha fazla bilgi için bkz: [zaman aşımı ve canlı tutma ayarlarını](#timeoutkeepalive) bu konuda daha sonra.</span><span class="sxs-lookup"><span data-stu-id="e6b45-178">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="e6b45-179">Düzenli aralıklarla bir bağlantısı etkin olduğunda, sunucu istemciye bir canlı tutma paketi gönderir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-179">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="e6b45-180">Bu makalenin yazıldığı tarih itibariyle varsayılan sıklık her 10 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-180">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="e6b45-181">Bu paketler için dinleyerek, istemciler bir bağlantı sorunu olup olmadığını söyleyebilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-181">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="e6b45-182">Keepalive paket beklenirken alınmazsa, kısa bir süre sonra istemci bağlantısı sorunlarını yavaşlığı veya kesintilerinin gibi olduğunu varsayar.</span><span class="sxs-lookup"><span data-stu-id="e6b45-182">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="e6b45-183">Keepalive daha uzun bir süre sonra hala alınmazsa, istemci bağlantı kesildi ve yeniden bağlanmayı denemeden başlar varsayar.</span><span class="sxs-lookup"><span data-stu-id="e6b45-183">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="e6b45-184">Aşağıdaki diyagram tipik bir senaryoda hemen aktarım API tarafından tanınmayan fiziksel bağlantı sorunları olduğunda oluşan istemci ve sunucu olayları gösterir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-184">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="e6b45-185">Diyagram için aşağıdaki koşullar geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="e6b45-185">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="e6b45-186">Taşıma WebSockets, sonsuza kadar çerçeve veya sunucu tarafından gönderilen olayları ' dir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-186">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="e6b45-187">Fiziksel ağ bağlantısını kesinti değişen dönemlerini vardır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-187">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="e6b45-188">SignalR bunları algılamak için keepalive işlevselliğini kullanır şekilde API taşıma kesintiler haberdar olmaz.</span><span class="sxs-lookup"><span data-stu-id="e6b45-188">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Taşıma bağlantısının kesilmesi](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="e6b45-190">İstemci modu yeniden bağlanmayı içine gider, ancak bağlantı kesme zaman aşımı sınırı içinde taşıma bağlantısı kurulamıyor, sunucunun SignalR bağlantıyı sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-190">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="e6b45-191">Bu durum oluştuğunda sunucunun Hub'ın yürütür `OnDisconnected` yöntemi ve daha sonra istemci yönetir durumda istemciye gönderilecek bir bağlantı kesme iletisi sıralarını.</span><span class="sxs-lookup"><span data-stu-id="e6b45-191">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="e6b45-192">İstemci daha sonra yeniden bağlanma, bağlantıyı kesme komutu ve çağrıları aldığı `Stop` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e6b45-192">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="e6b45-193">Bu senaryoda, `OnReconnected` istemci bağlandığında yürütülmedi ve `OnDisconnected` istemci çağırdığında yürütülmedi `Stop`.</span><span class="sxs-lookup"><span data-stu-id="e6b45-193">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="e6b45-194">Aşağıdaki diyagramda, bu senaryo gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-194">The following diagram illustrates this scenario.</span></span>

![Aktarım kesintilerini - sunucu zaman aşımı](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="e6b45-196">İstemci üzerinde gerçekleştirilen SignalR bağlantısı ömür olayları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="e6b45-196">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="e6b45-197">`ConnectionSlow`İstemci olay.</span><span class="sxs-lookup"><span data-stu-id="e6b45-197">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="e6b45-198">Keepalive zaman aşımı süresi önceden belirlenmiş bir kısmının bu yana en son iletinin geçti veya keepalive ping alındı tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-198">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="e6b45-199">Varsayılan keepalive uyarı zaman aşımını 2/3 keepalive zaman aşımı olur.</span><span class="sxs-lookup"><span data-stu-id="e6b45-199">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="e6b45-200">Uyarı hakkında 13 saniyede oluşmaz canlı tutma zaman aşımı 20 saniye kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-200">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="e6b45-201">Varsayılan olarak, sunucu, 10 saniyede keepalive ping gönderir ve istemci keepalive ping 2 saniyede (üçte keepalive zaman aşımı değeri keepalive zaman aşımı uyarısı değeri arasındaki farkı) hakkında denetler.</span><span class="sxs-lookup"><span data-stu-id="e6b45-201">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="e6b45-202">API taşıma bir bağlantısının kesilmesi uyumlu hale gelirse, keepalive uyarı zaman aşımını geçirmeden önce SignalR bağlantısının kesilmesi bilgilendirilmek.</span><span class="sxs-lookup"><span data-stu-id="e6b45-202">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="e6b45-203">Bu durumda, `ConnectionSlow` değil olayı ve SignalR Git doğrudan `Reconnecting` olay.</span><span class="sxs-lookup"><span data-stu-id="e6b45-203">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="e6b45-204">`Reconnecting`İstemci olay.</span><span class="sxs-lookup"><span data-stu-id="e6b45-204">`Reconnecting` client event.</span></span>

    <span data-ttu-id="e6b45-205">(A) API taşıma bağlantısı kesildiği veya bu yana en son iletinin (b keepalive zaman aşımı süresi geçmiş veya keepalive ping alındı algıladığında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6b45-205">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="e6b45-206">SignalR istemci kodu yeniden denemeye başlar.</span><span class="sxs-lookup"><span data-stu-id="e6b45-206">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="e6b45-207">Taşıma bağlantısı kesildiğinde bazı işlemler yapması için uygulamanızın istiyorsanız bu olay işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-207">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="e6b45-208">Varsayılan keepalive zaman aşımı süresi şu anda 20 saniye kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-208">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="e6b45-209">SignalR modu yeniden bağlanmayı olsa da bir Hub yöntemini çağırmak, istemci kodunuzun çalışırsa, SignalR komutu göndermeyi dener.</span><span class="sxs-lookup"><span data-stu-id="e6b45-209">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="e6b45-210">Çoğu zaman, bu tür denemeleri başarısız olur, ancak bazı durumlarda bunlar başarılı olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-210">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="e6b45-211">Sunucu tarafından gönderilen olaylar, sonsuza kadar çerçeve ve uzun yoklama taşıma için SignalR iki iletişim kanalı, iletileri göndermek için istemcinin kullandığı diğeri iletileri almak için kullandığı kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-211">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="e6b45-212">Alma için kullanılan kalıcı olarak açık bir kanaldır, ve fiziksel bağlantısı kesildiğinde, kapalı bir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-212">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="e6b45-213">Fiziksel bağlantı geri yüklediyseniz, alma kanal yeniden kurulur kurulmaz önce yöntem çağrısı istemciden sunucuya başarılı olabilir kullanılabilir kalır göndermek için kullanılan kanalı.</span><span class="sxs-lookup"><span data-stu-id="e6b45-213">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="e6b45-214">SignalR alma için kullanılan kanal yeniden açar kadar dönüş değeri alınmadı.</span><span class="sxs-lookup"><span data-stu-id="e6b45-214">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="e6b45-215">`Reconnected`İstemci olay.</span><span class="sxs-lookup"><span data-stu-id="e6b45-215">`Reconnected` client event.</span></span>

    <span data-ttu-id="e6b45-216">Taşıma bağlantısı yeniden kurulduğunda oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6b45-216">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="e6b45-217">`OnReconnected` Olay işleyicisi hub yürütür.</span><span class="sxs-lookup"><span data-stu-id="e6b45-217">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="e6b45-218">`Closed`İstemci olayı (`disconnected` JavaScript olayda).</span><span class="sxs-lookup"><span data-stu-id="e6b45-218">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="e6b45-219">SignalR istemci kodu taşıma bağlantısını kaybettikten sonra yeniden yapmaya çalışırken bağlantı kesme zaman aşımı süresi sona erdiğinde oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="e6b45-219">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="e6b45-220">Varsayılan bağlantı kesme zaman aşımı olan 30 saniye.</span><span class="sxs-lookup"><span data-stu-id="e6b45-220">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="e6b45-221">(Çünkü bağlantı sona erdiğinde de bu olay tetiklenir `Stop` yöntemi çağrılır.)</span><span class="sxs-lookup"><span data-stu-id="e6b45-221">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="e6b45-222">Aktarım API tarafından algılanmayan ve keepalive ping keepalive uyarı zaman aşımını daha uzun süre sunucudan alınması beklemeyin aktarım bağlantı kesintileri herhangi bir bağlantı çıkarılmasına ömür olayları neden.</span><span class="sxs-lookup"><span data-stu-id="e6b45-222">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="e6b45-223">Bazı ağ ortamları kasıtlı olarak boşta kalma bağlantıları kapatın ve başka bir keepalive paketlerin bu bu ağlar bir SignalR bağlantısı kullanımda olduğunu biliyor veren tarafından önlemeye yardımcı olmak için işlevdir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-223">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="e6b45-224">Olağanüstü durumlarda keepalive ping varsayılan sıklığını kapalı bağlantıları önlemek için yeterli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-224">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="e6b45-225">Bu durumda daha sık gönderilmesini keepalive ping yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6b45-225">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="e6b45-226">Daha fazla bilgi için bkz: [zaman aşımı ve canlı tutma ayarlarını](#timeoutkeepalive) bu konuda daha sonra.</span><span class="sxs-lookup"><span data-stu-id="e6b45-226">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="e6b45-227">**Önemli**: Burada açıklanan olayların sırası garanti edilmez.</span><span class="sxs-lookup"><span data-stu-id="e6b45-227">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="e6b45-228">SignalR bağlantısı ömür olayları bu düzene göre tahmin edilebilir bir şekilde yükseltmek için her girişiminde bulunur, ancak ağ olayları çeşitli türleri ve hangi aktarım API'leri gibi temel iletişimleri çerçeveleri bunları işlemek birçok yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-228">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="e6b45-229">Örneğin, `Reconnected` istemci yeniden bağlandığında, olay oluşmayabilir veya `OnConnected` bağlantı girişimi başarısız olduğunda, sunucuda işleyici çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6b45-229">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="e6b45-230">Bu konu, normalde normal belirli koşullar tarafından üretilen etkilerini açıklar.</span><span class="sxs-lookup"><span data-stu-id="e6b45-230">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="e6b45-231">İstemci bağlantısının kesilmesine senaryoları</span><span class="sxs-lookup"><span data-stu-id="e6b45-231">Client disconnection scenarios</span></span>

<span data-ttu-id="e6b45-232">Bir tarayıcı istemci bir SignalR bağlantısı tutar SignalR istemci kodu bir web sayfasında JavaScript bağlamında çalışır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-232">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="e6b45-233">Sahip birinden gittiğinizde sonlandırmak SignalR bağlantısı olan neden sayfasında üzere başka bir ve o kullanıcının neden varsa birden çok bağlantı kimlikleri ile birden çok bağlantı birden çok tarayıcı pencerelerini veya sekmeler bağlanın.</span><span class="sxs-lookup"><span data-stu-id="e6b45-233">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="e6b45-234">Kullanıcı bir tarayıcı penceresi veya sekmesinde kapatır veya yeni bir sayfasına gider veya sayfa yenilendikten, siz ve çağrıları için SignalR istemci kodu tarayıcı olay işleme için SignalR bağlantısı hemen sona erer `Stop` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e6b45-234">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="e6b45-235">Bu senaryolar veya uygulamanız çağırdığında tüm istemci platformu `Stop` yöntemi, `OnDisconnected` olay işleyicisi yürütür hemen sunucuda ve istemci başlatır `Closed` olay (olay adlı `disconnected` içinde JavaScript için).</span><span class="sxs-lookup"><span data-stu-id="e6b45-235">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="e6b45-236">Bir istemci uygulaması veya üzerinde çalıştığı bilgisayar kilitlenmesine veya (örneğin, kullanıcının dizüstü bilgisayar kapandığında) uyku moduna geçer, sunucunun hakkında ne olduğu bilgisi yok.</span><span class="sxs-lookup"><span data-stu-id="e6b45-236">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="e6b45-237">Sunucu bilir kadar istemci kaybı bağlantı kesintisi nedeniyle olabilir ve istemci yeniden çalışıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-237">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="e6b45-238">Bu nedenle, sunucunun beklediği istemci yeniden bağlanmak için bir fırsat vermek için bu senaryolarda ve `OnDisconnected` (yaklaşık 30 saniye varsayılan olarak) bağlantı kesme zaman aşımı süresi sona erene kadar yürütmez.</span><span class="sxs-lookup"><span data-stu-id="e6b45-238">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="e6b45-239">Aşağıdaki diyagramda, bu senaryo gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-239">The following diagram illustrates this scenario.</span></span>

![İstemci bilgisayar hatası](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="e6b45-241">Sunucu bağlantı kesme senaryoları</span><span class="sxs-lookup"><span data-stu-id="e6b45-241">Server disconnection scenarios</span></span>

<span data-ttu-id="e6b45-242">Bir sunucu çevrimdışı--olduğunda yeniden başlatır, başarısız, uygulama etki alanı dönüştürür, vb.--nedeni bağlantı kesildi benzer olabilir veya SignalR ve aktarım API hemen sunucu kayboluyor ve SignalR başlamak olmadan yeniden bağlanmaya biliyor olabilirsiniz yükseltme `ConnectionSlow` olay.</span><span class="sxs-lookup"><span data-stu-id="e6b45-242">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="e6b45-243">İstemci, istemci modu yeniden bağlanmayı içine kalırsa ve sunucuyu kurtarır veya bağlantı kesme zaman aşımı süresi sona ermeden önce yeniden başlatma veya yeni bir sunucu çevrimiçi duruma geri yüklenen veya yeni bir sunucuya yeniden bağlanır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-243">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="e6b45-244">Bu durumda, istemci üzerinde bir SignalR bağlantısı devam eder ve `Reconnected` olayı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6b45-244">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="e6b45-245">İlk sunucuda `OnDisconnected` hiçbir zaman yürütülür ve yeni sunucudaki `OnReconnected` rağmen yürütülen `OnConnected` hiçbir zaman önce o sunucuda istemci için yürütüldü.</span><span class="sxs-lookup"><span data-stu-id="e6b45-245">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="e6b45-246">(Aynı sunucu onu yeniden başlatıldığında olduğundan istemci bir yeniden başlatma veya uygulama etki alanı geri dönüşüm sonra aynı sunucuya bağlanırsa önceki bağlantı etkinlik belleğe sahip değil etkili olur.) Aşağıdaki diyagramda API taşıma hemen bağlantı kesildi uyumlu hale varsayar böylece `ConnectionSlow` olayı oluşmaz.</span><span class="sxs-lookup"><span data-stu-id="e6b45-246">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Sunucu hatası ve yeniden bağlanma](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="e6b45-248">Bir sunucu bağlantı kesme zaman aşımı süresi içinde kullanılabilir olmaz, SignalR bağlantıyı sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-248">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="e6b45-249">Bu senaryoda, `Closed` olayı (`disconnected` JavaScript istemcilerinin) istemci üzerinde oluşturulur ancak `OnDisconnected` sunucu üzerinde hiçbir zaman çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-249">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="e6b45-250">Aşağıdaki diyagramda SignalR keepalive işlevsellik tarafından algılandığı şekilde API aktarım bağlantı kesildi, farkında olmaz olduğunu varsayar ve `ConnectionSlow` olayı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e6b45-250">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Sunucu hatası ve zaman aşımı](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="e6b45-252">Zaman aşımı ve canlı tutma ayarları</span><span class="sxs-lookup"><span data-stu-id="e6b45-252">Timeout and keepalive settings</span></span>

<span data-ttu-id="e6b45-253">Varsayılan `ConnectionTimeout`, `DisconnectTimeout`, ve `KeepAlive` değerleri çoğu senaryosu için uygun olan ancak ortamınıza özel gereksinimleri varsa değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-253">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="e6b45-254">Örneğin, ağ ortamınızı 5 saniye süreyle boşta olan bağlantıların kapatırsa, keepalive değerini azaltın gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-254">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="e6b45-255">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="e6b45-255">ConnectionTimeout</span></span>

<span data-ttu-id="e6b45-256">Bu ayar, bir taşıma bağlantısı açık ve kapatıp yeni bir bağlantı açarak önce bir yanıtı beklenirken bırakın süreyi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="e6b45-256">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="e6b45-257">Varsayılan değer 110 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-257">The default value is 110 seconds.</span></span>

<span data-ttu-id="e6b45-258">Bu ayar, yalnızca zaman keepalive işlevselliği, normalde geçerli olduğu yalnızca uzun süre devre dışı bırakıldı geçerlidir yoklama taşıması.</span><span class="sxs-lookup"><span data-stu-id="e6b45-258">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="e6b45-259">Aşağıdaki diyagramda bir uzun üzerinde bu ayarın etkisi gösterilmektedir yoklama taşıma bağlantısı.</span><span class="sxs-lookup"><span data-stu-id="e6b45-259">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Uzun yoklama taşıma bağlantısı](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="e6b45-261">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="e6b45-261">DisconnectTimeout</span></span>

<span data-ttu-id="e6b45-262">Bu ayar tetiklenmeden önce taşıma bağlantısı kaybedildi sonra beklenecek süreyi temsil eden `Disconnected` olay.</span><span class="sxs-lookup"><span data-stu-id="e6b45-262">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="e6b45-263">Varsayılan değer 30 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-263">The default value is 30 seconds.</span></span> <span data-ttu-id="e6b45-264">Ayarladığınızda `DisconnectTimeout`, `KeepAlive` otomatik olarak 1/3'e ayarlanır `DisconnectTimeout` değeri.</span><span class="sxs-lookup"><span data-stu-id="e6b45-264">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="e6b45-265">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="e6b45-265">KeepAlive</span></span>

<span data-ttu-id="e6b45-266">Bu ayar boştaki bir bağlantı üzerinden canlı tutma paketi göndermeden önce beklenecek süreyi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="e6b45-266">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="e6b45-267">Varsayılan değer 10 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-267">The default value is 10 seconds.</span></span> <span data-ttu-id="e6b45-268">Bu değer birden fazla 1/3 / olmamalıdır `DisconnectTimeout` değeri.</span><span class="sxs-lookup"><span data-stu-id="e6b45-268">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="e6b45-269">Her ikisi de ayarlamak istiyorsanız `DisconnectTimeout` ve `KeepAlive`ayarlayın `KeepAlive` sonra `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="e6b45-269">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="e6b45-270">Aksi takdirde, `KeepAlive` ayarı olacaktır üzerine ne zaman `DisconnectTimeout` otomatik olarak ayarlar `KeepAlive` zaman aşımı değeri 1/3.</span><span class="sxs-lookup"><span data-stu-id="e6b45-270">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="e6b45-271">Keepalive işlevini devre dışı bırakmak istiyorsanız, `KeepAlive` null.</span><span class="sxs-lookup"><span data-stu-id="e6b45-271">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="e6b45-272">KeepAlive işlevselliği otomatik olarak uzun süre devre dışı yoklama taşıması.</span><span class="sxs-lookup"><span data-stu-id="e6b45-272">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="e6b45-273">Zaman aşımı ve canlı tutma ayarlarını değiştirme</span><span class="sxs-lookup"><span data-stu-id="e6b45-273">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="e6b45-274">Bu ayarlar için varsayılan değerleri değiştirmek için bunları kümesinde `Application_Start` içinde *Global.asax* , aşağıdaki örnekte gösterildiği gibi dosya.</span><span class="sxs-lookup"><span data-stu-id="e6b45-274">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="e6b45-275">Örnek kodda gösterilen değerleri varsayılan değerleri ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="e6b45-275">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="e6b45-276">Bağlantı kesilmeleri hakkında kullanıcıya bildirim nasıl</span><span class="sxs-lookup"><span data-stu-id="e6b45-276">How to notify the user about disconnections</span></span>

<span data-ttu-id="e6b45-277">Bazı uygulamalarda bağlantısı sorunları olduğunda kullanıcıya bir ileti görüntülemek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6b45-277">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="e6b45-278">Nasıl için çeşitli seçenekler ve bunu yapmak ne zaman var.</span><span class="sxs-lookup"><span data-stu-id="e6b45-278">You have several options for how and when to do this.</span></span> <span data-ttu-id="e6b45-279">Aşağıdaki kod örnekleri oluşturulan proxy kullanan bir JavaScript istemci için ' dir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-279">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="e6b45-280">Tanıtıcı `connectionSlow` olay modu yeniden bağlanmayı içine geçmeden önce SignalR, bağlantı sorunların farkında hemen bir ileti görüntüler.</span><span class="sxs-lookup"><span data-stu-id="e6b45-280">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="e6b45-281">Tanıtıcı `reconnecting` olay SignalR bağlantı kesme farkındadır ve modu yeniden bağlanmayı içine gittiği zaman bir ileti görüntüler.</span><span class="sxs-lookup"><span data-stu-id="e6b45-281">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="e6b45-282">İşleme `disconnected` bir ileti yeniden bağlanma girişimi zaman görüntülemek için olay zaman aşımına uğradı. Bu senaryoda, sunucu ile bir bağlantı yeniden yeniden oluşturmak için tek yolu bir SignalR bağlantısı çağırarak yeniden başlatmaktır `Start` yeni bir bağlantı kimliği oluşturacak yöntemi</span><span class="sxs-lookup"><span data-stu-id="e6b45-282">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="e6b45-283">Aşağıdaki kod örneği yalnızca yeniden bağlanan bir zaman aşımından sonra bildirim değil çağırarak neden SignalR bağlantısı normal sonuna sonra sorun emin olmak için bir bayrak kullanır `Stop` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e6b45-283">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="e6b45-284">Sürekli olarak yeniden bağlama</span><span class="sxs-lookup"><span data-stu-id="e6b45-284">How to continuously reconnect</span></span>

<span data-ttu-id="e6b45-285">Bazı uygulamalarda otomatik olarak bağlantı kaybı oldu ve yeniden bağlanma girişimi zaman aşımına uğradı sonra yeniden oluşturmak isteyebilirsiniz. Bunu yapmak için çağırabilirsiniz `Start` yönteminden, `Closed` olay işleyicisi (`disconnected` olay işleyicisi JavaScript istemcilerde).</span><span class="sxs-lookup"><span data-stu-id="e6b45-285">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="e6b45-286">Çağırmadan önce bir süre bekleyin isteyebilirsiniz `Start` çok Bunu önlemek için sık sunucu ya da fiziksel bağlantısı olduğunda kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="e6b45-286">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="e6b45-287">Aşağıdaki kod örneği oluşturulan proxy kullanan bir JavaScript istemci için ' dir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-287">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="e6b45-288">Mobil istemcilerin dikkat edilmesi gereken olası bir sorunu, sunucu ya da fiziksel bağlantı kullanılamadığında sürekli yeniden bağlanma denemesi gereksiz pil boşaltma neden olabilecek ' dir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-288">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="e6b45-289">Bir istemci sunucu kodunda kesme hakkında</span><span class="sxs-lookup"><span data-stu-id="e6b45-289">How to disconnect a client in server code</span></span>

<span data-ttu-id="e6b45-290">SignalR sürüm 2 istemcileri kesme için yerleşik bir sunucu API yok.</span><span class="sxs-lookup"><span data-stu-id="e6b45-290">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="e6b45-291">Vardır [bu işlevselliği gelecekte ekleme planları](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="e6b45-291">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="e6b45-292">Geçerli SignalR sürümü, bir istemci sunucu bağlantısını kesmek için basit bir bağlantıyı kes yöntemi istemcide uygulamak ve sunucudan bu yöntemi çağırabilmeniz için yoldur.</span><span class="sxs-lookup"><span data-stu-id="e6b45-292">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="e6b45-293">Aşağıdaki kod örneği, oluşturulan proxy kullanan bir JavaScript istemci için bir bağlantı kesme yöntemi gösterilir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-293">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="e6b45-294">Güvenlik - ne istemcileri kesme için bu yöntem ne de önerilen yerleşik API adres kötü amaçlı kod istemcileri yeniden bağlanma veya kullanılan kod kaldırabilir beri çalıştırılan kullanılan istemcileri senaryo `stopClient` yöntemi veya değiştirme bunu yapar.</span><span class="sxs-lookup"><span data-stu-id="e6b45-294">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="e6b45-295">Durum bilgisi olan hizmet reddi (DOS) koruması uygulamak için uygun framework veya sunucu katman değil, ön uç altyapısı yerdir.</span><span class="sxs-lookup"><span data-stu-id="e6b45-295">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="e6b45-296">Bağlantı kesme nedeni algılama</span><span class="sxs-lookup"><span data-stu-id="e6b45-296">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="e6b45-297">SignalR 2.1 sunucuya bir aşırı ekler `OnDisconnect` zaman aşımına uğramadan yerine istemci kasıtlı olarak bağlantısı olmadığını belirten bir olay. `StopCalled` Parametredir istemci açıkça bağlantı kapalı olduğunda true.</span><span class="sxs-lookup"><span data-stu-id="e6b45-297">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="e6b45-298">İstemcinin bağlantısını kesmek için bir sunucu hatası neden olursa, JavaScript'te hata bilgilerini istemci olarak geçirilecektir `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="e6b45-298">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="e6b45-299">**C# sunucu kodu: `stopCalled` parametresi**</span><span class="sxs-lookup"><span data-stu-id="e6b45-299">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="e6b45-300">**JavaScript istemci kodu: erişme `lastError` içinde `disconnect` olay.**</span><span class="sxs-lookup"><span data-stu-id="e6b45-300">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
