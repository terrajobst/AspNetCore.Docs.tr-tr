---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: Etkinleştirme otomatik birim testi | Microsoft Docs
author: microsoft
description: 12. adımı bizim NerdDinner işlevselliğini doğrulayın ve hangi bize değişiklik yapmak için güvenirlik verecektir otomatik birim testleri dizisi geliştirmek gösterilmektedir...
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/27/2010
ms.topic: article
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: fede08be7e06327c6d04fa5d36f7dd818d79b380
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/06/2018
ms.locfileid: "30875636"
---
<a name="enable-automated-unit-testing"></a><span data-ttu-id="6b96e-103">Otomatik birim testi etkinleştir</span><span class="sxs-lookup"><span data-stu-id="6b96e-103">Enable Automated Unit Testing</span></span>
====================
<span data-ttu-id="6b96e-104">tarafından [Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="6b96e-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="6b96e-105">PDF indirin</span><span class="sxs-lookup"><span data-stu-id="6b96e-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="6b96e-106">12. adımı bir ücretsiz budur ["NerdDinner" uygulaması Öğreticisi](introducing-the-nerddinner-tutorial.md) , yetenekte küçük bir yapı ancak tamamlandı, ASP.NET MVC 1 kullanarak web uygulamasına nasıl aracılığıyla.</span><span class="sxs-lookup"><span data-stu-id="6b96e-106">This is step 12 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="6b96e-107">Adım 12 bizim NerdDinner işlevselliğini doğrulayın ve hangi bize güvenirlik ve uygulama gelecekte geliştirmeleri değişiklik verecektir otomatik birim testleri dizisi geliştirmek nasıl gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-107">Step 12 shows how to develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>
> 
> <span data-ttu-id="6b96e-108">ASP.NET MVC 3 kullanıyorsanız, izlemeniz önerilir [MVC 3 ile çalışmaya başlama](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) veya [MVC müzik deposu](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) öğreticileri.</span><span class="sxs-lookup"><span data-stu-id="6b96e-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>


## <a name="nerddinner-step-12-unit-testing"></a><span data-ttu-id="6b96e-109">NerdDinner 12. adım: Birim testi</span><span class="sxs-lookup"><span data-stu-id="6b96e-109">NerdDinner Step 12: Unit Testing</span></span>

<span data-ttu-id="6b96e-110">Şimdi bizim NerdDinner işlevselliğini doğrulayın ve hangi bize güvenirlik ve uygulama gelecekte geliştirmeleri değişiklik verecektir otomatik birim testleri dizisi geliştirin.</span><span class="sxs-lookup"><span data-stu-id="6b96e-110">Let's develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>

### <a name="why-unit-test"></a><span data-ttu-id="6b96e-111">Neden birim testi?</span><span class="sxs-lookup"><span data-stu-id="6b96e-111">Why Unit Test?</span></span>

<span data-ttu-id="6b96e-112">İş bir sabah sürücüsüne üzerinde ani bir flash, üzerinde çalıştığınız uygulama hakkında fikir sahip.</span><span class="sxs-lookup"><span data-stu-id="6b96e-112">On the drive into work one morning you have a sudden flash of inspiration about an application you are working on.</span></span> <span data-ttu-id="6b96e-113">Uygulama önemli ölçüde daha iyi hale getirir, uygulayabileceğiniz bir değişiklik unutmayın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-113">You realize there is a change you can implement that will make the application dramatically better.</span></span> <span data-ttu-id="6b96e-114">Bir kod temizler, yeni bir özellik ekler veya bir hata düzeltmeleri yeniden düzenleme olabilir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-114">It might be a refactoring that cleans up the code, adds a new feature, or fixes a bug.</span></span>

<span data-ttu-id="6b96e-115">Bilgisayarınızın başında geldiğinde, confronts Soru – "Bu geliştirme olmak için ne kadar güvenli mi?"</span><span class="sxs-lookup"><span data-stu-id="6b96e-115">The question that confronts you when you arrive at your computer is – "how safe is it to make this improvement?"</span></span> <span data-ttu-id="6b96e-116">Ne değişikliği yapmadan yan etkileri var mı yoksa bir şey keser?</span><span class="sxs-lookup"><span data-stu-id="6b96e-116">What if making the change has side effects or breaks something?</span></span> <span data-ttu-id="6b96e-117">Değişiklik basit ve yalnızca uygulamak için birkaç dakika, ancak ne el ile tüm uygulama senaryolarını sınamak için saat sürer sürer?</span><span class="sxs-lookup"><span data-stu-id="6b96e-117">The change might be simple and only take a few minutes to implement, but what if it takes hours to manually test out all of the application scenarios?</span></span> <span data-ttu-id="6b96e-118">Ne bir senaryoda ele unutursanız ve başarısız bir uygulama üretime geçmeden?</span><span class="sxs-lookup"><span data-stu-id="6b96e-118">What if you forget to cover a scenario and a broken application goes into production?</span></span> <span data-ttu-id="6b96e-119">Bu geliştirme gerçekten tüm çaba değerinde yapıyor mu?</span><span class="sxs-lookup"><span data-stu-id="6b96e-119">Is making this improvement really worth all the effort?</span></span>

<span data-ttu-id="6b96e-120">Otomatikleştirilmiş testler uygulamalarınızı sürekli olarak geliştirmenize olanak tanıyan bir güvenlik ağı sağlayın ve üzerinde çalıştığınız kod afraid olan kaçının.</span><span class="sxs-lookup"><span data-stu-id="6b96e-120">Automated unit tests can provide a safety net that enables you to continually enhance your applications, and avoid being afraid of the code you are working on.</span></span> <span data-ttu-id="6b96e-121">Hızlı bir şekilde işlevsellik güvenle – kod ve size, aksi takdirde rahat Keçeli değil geliştirmeler yapmak için güç kazandırma sağlar doğrulayın testleri otomatik yapılıyor.</span><span class="sxs-lookup"><span data-stu-id="6b96e-121">Having automated tests that quickly verify functionality enables you to code with confidence – and empower you to make improvements you might otherwise not have felt comfortable doing.</span></span> <span data-ttu-id="6b96e-122">Ayrıca daha rahat çözümleri oluşturma ve hangi müşteri adaylarını daha yüksek yatırım getirisi uzun ömrü - yardımcı olurlar.</span><span class="sxs-lookup"><span data-stu-id="6b96e-122">They also help create solutions that are more maintainable and have a longer lifetime - which leads to a much higher return on investment.</span></span>

<span data-ttu-id="6b96e-123">ASP.NET MVC çerçevesi, kolay ve birim testi uygulama işlevine doğal kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-123">The ASP.NET MVC Framework makes it easy and natural to unit test application functionality.</span></span> <span data-ttu-id="6b96e-124">Ayrıca, önce test tabanlı geliştirme sağlayan bir Test güdümlü geliştirme (TDD) iş akışı sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b96e-124">It also enables a Test Driven Development (TDD) workflow that enables test-first based development.</span></span>

### <a name="nerddinnertests-project"></a><span data-ttu-id="6b96e-125">NerdDinner.Tests Project</span><span class="sxs-lookup"><span data-stu-id="6b96e-125">NerdDinner.Tests Project</span></span>

<span data-ttu-id="6b96e-126">Bu öğretici, başında NerdDinner uygulamamız oluşturduğumuz, biz biz yanı sıra uygulama projesi gitmek için birim testi projesi oluşturmak istemeniz olup olmadığını soran bir iletişim kutusuyla istenmiş:</span><span class="sxs-lookup"><span data-stu-id="6b96e-126">When we created our NerdDinner application at the beginning of this tutorial, we were prompted with a dialog asking whether we wanted to create a unit test project to go along with the application project:</span></span>

![](enable-automated-unit-testing/_static/image1.png)

<span data-ttu-id="6b96e-127">Biz bizim çözüme eklenmekte olan "NerdDinner.Tests" projesinde sonuçlandı seçili – "Evet, birim testi projesi oluşturma" radyo düğmesinin tutulur:</span><span class="sxs-lookup"><span data-stu-id="6b96e-127">We kept the "Yes, create a unit test project" radio button selected – which resulted in a "NerdDinner.Tests" project being added to our solution:</span></span>

![](enable-automated-unit-testing/_static/image2.png)

<span data-ttu-id="6b96e-128">NerdDinner.Tests proje NerdDinner uygulama projesi bütünleştirilmiş koduna başvuruyor ve bize otomatikleştirilmiş testleri uygulama işlevselliğini doğrulayın, kolayca eklemenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b96e-128">The NerdDinner.Tests project references the NerdDinner application project assembly, and enables us to easily add automated tests to it that verify the application functionality.</span></span>

### <a name="creating-unit-tests-for-our-dinner-model-class"></a><span data-ttu-id="6b96e-129">Bizim Yemeği Model sınıfı için birim testleri oluşturma</span><span class="sxs-lookup"><span data-stu-id="6b96e-129">Creating Unit Tests for our Dinner Model Class</span></span>

<span data-ttu-id="6b96e-130">Bazı testleri NerdDinner.Tests Projemizin bizim modeli katmanı oluşturduğumuz zaman oluşturduğumuz Yemeği sınıfı doğrulayın ekleyelim.</span><span class="sxs-lookup"><span data-stu-id="6b96e-130">Let's add some tests to our NerdDinner.Tests project that verify the Dinner class we created when we built our model layer.</span></span>

<span data-ttu-id="6b96e-131">Biz bizim modeli ilgili testleri nereye yeni bir klasör içinde "Modelleri" adlı bizim test projesi oluşturarak başlayacağız.</span><span class="sxs-lookup"><span data-stu-id="6b96e-131">We'll start by creating a new folder within our test project called "Models" where we'll place our model-related tests.</span></span> <span data-ttu-id="6b96e-132">Biz ardından klasörü sağ tıklatın ve seçin **Ekle -&gt;Yeni Test** menü komutu.</span><span class="sxs-lookup"><span data-stu-id="6b96e-132">We'll then right-click on the folder and choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="6b96e-133">Bu, "Yeni Test Ekle" iletişim kutusunu getirir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-133">This will bring up the "Add New Test" dialog.</span></span>

<span data-ttu-id="6b96e-134">"Birim testi" oluşturmak ve "DinnerTest.cs" adlandırmak seçeceğiz:</span><span class="sxs-lookup"><span data-stu-id="6b96e-134">We'll choose to create a "Unit Test" and name it "DinnerTest.cs":</span></span>

![](enable-automated-unit-testing/_static/image3.png)

<span data-ttu-id="6b96e-135">Biz "Tamam" düğmesine tıkladığınızda Visual Studio ekleyin (açın projesine bir DinnerTest.cs dosyasını ve):</span><span class="sxs-lookup"><span data-stu-id="6b96e-135">When we click the "ok" button Visual Studio will add (and open) a DinnerTest.cs file to the project:</span></span>

![](enable-automated-unit-testing/_static/image4.png)

<span data-ttu-id="6b96e-136">Varsayılan Visual Studio birim test şablonu kazan kalıbı kodunu biraz düzensiz bulabilirim, içinde bir grup yok.</span><span class="sxs-lookup"><span data-stu-id="6b96e-136">The default Visual Studio unit test template has a bunch of boiler-plate code within it that I find a little messy.</span></span> <span data-ttu-id="6b96e-137">Şimdi, yalnızca aşağıdaki kodu içerecek şekilde temizleme:</span><span class="sxs-lookup"><span data-stu-id="6b96e-137">Let's clean it up to just contain the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

<span data-ttu-id="6b96e-138">Yukarıdaki DinnerTest sınıfı [TestClass] öznitelikte testleri, hem de isteğe bağlı sınama başlatma ve erdirme kodu içeren bir sınıf olarak tanımlar.</span><span class="sxs-lookup"><span data-stu-id="6b96e-138">The [TestClass] attribute on the DinnerTest class above identifies it as a class that will contain tests, as well as optional test initialization and teardown code.</span></span> <span data-ttu-id="6b96e-139">[TestMethod] özniteliği olan genel yöntemler ekleyerek biz Bu testlerde tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-139">We can define tests within it by adding public methods that have a [TestMethod] attribute on them.</span></span>

<span data-ttu-id="6b96e-140">Bizim Yemeği sınıfı çalışma ekleyeceğiz iki testleri ilk altındadır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-140">Below are the first of two tests we'll add that exercise our Dinner class.</span></span> <span data-ttu-id="6b96e-141">İlk testi yeni Yemeği doğru olarak ayarlanan tüm özellikleri olmadan oluşturulursa bizim Yemeği geçersiz olduğunu doğrular.</span><span class="sxs-lookup"><span data-stu-id="6b96e-141">The first test verifies that our Dinner is invalid if a new Dinner is created without all properties being set correctly.</span></span> <span data-ttu-id="6b96e-142">İkinci test bir Yemeği geçerli değerlerle ayarlamak tüm özelliklere sahip olduğunda bizim Yemeği geçerli olduğunu doğrular:</span><span class="sxs-lookup"><span data-stu-id="6b96e-142">The second test verifies that our Dinner is valid when a Dinner has all properties set with valid values:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

<span data-ttu-id="6b96e-143">Bizim test adları çok açık (ve biraz ayrıntılı) yukarıdaki fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-143">You'll notice above that our test names are very explicit (and somewhat verbose).</span></span> <span data-ttu-id="6b96e-144">Biz bu çünkü biz yüzlerce veya binlerce küçük testleri oluşturma yukarı bitiş ve (özellikle bir test Çalıştırıcısı'nda hataları listesi aracılığıyla arıyoruz) hızlı bir şekilde amacını ve bunların her birini davranışını belirlerken kolaylaştırmak istiyoruz yaparsınız.</span><span class="sxs-lookup"><span data-stu-id="6b96e-144">We are doing this because we might end up creating hundreds or thousands of small tests, and we want to make it easy to quickly determine the intent and behavior of each of them (especially when we are looking through a list of failures in a test runner).</span></span> <span data-ttu-id="6b96e-145">Test adları test ettiğiniz işlevselliği sonra adlı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-145">The test names should be named after the functionality they are testing.</span></span> <span data-ttu-id="6b96e-146">Yukarıdaki kullanıyoruz bir "isim\_gereken\_fiil" adlandırma deseni.</span><span class="sxs-lookup"><span data-stu-id="6b96e-146">Above we are using a "Noun\_Should\_Verb" naming pattern.</span></span>

<span data-ttu-id="6b96e-147">Biz "" Yerleştir Act, Assert"anlamına gelir düzeni – sınama AAA" kullanarak testleri yapılandırılması:</span><span class="sxs-lookup"><span data-stu-id="6b96e-147">We are structuring the tests using the "AAA" testing pattern – which stands for "Arrange, Act, Assert":</span></span>

- <span data-ttu-id="6b96e-148">Düzenleyin: sınanan birim Kurulum</span><span class="sxs-lookup"><span data-stu-id="6b96e-148">Arrange: Setup the unit being tested</span></span>
- <span data-ttu-id="6b96e-149">ACT: birim testi altında uygulamanız ve sonuçları yakalama</span><span class="sxs-lookup"><span data-stu-id="6b96e-149">Act: Exercise the unit under test and capture results</span></span>
- <span data-ttu-id="6b96e-150">Assert: davranışı doğrulayın</span><span class="sxs-lookup"><span data-stu-id="6b96e-150">Assert: Verify the behavior</span></span>

<span data-ttu-id="6b96e-151">Biz yazdığınızda tek tek testlerin zorunda kalmamak için istiyoruz testleri çok yapın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-151">When we write tests we want to avoid having the individual tests do too much.</span></span> <span data-ttu-id="6b96e-152">Bunun yerine her test (hangi başarısızlık sabitleme çok daha kolay hale getirir) bir tek kavramı doğrulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-152">Instead each test should verify only a single concept (which will make it much easier to pinpoint the cause of failures).</span></span> <span data-ttu-id="6b96e-153">İyi kılavuz deneyin ve yalnızca tek bir her test için deyimi assert sahip olmaktır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-153">A good guideline is to try and only have a single assert statement for each test.</span></span> <span data-ttu-id="6b96e-154">Birden fazla test yöntemine deyimi assert varsa, bunların tümü aynı kavram test etmek için kullanılan emin olun.</span><span class="sxs-lookup"><span data-stu-id="6b96e-154">If you have more than one assert statement in a test method, make sure they are all being used to test the same concept.</span></span> <span data-ttu-id="6b96e-155">Şüpheli olduğunda, başka bir test olun.</span><span class="sxs-lookup"><span data-stu-id="6b96e-155">When in doubt, make another test.</span></span>

### <a name="running-tests"></a><span data-ttu-id="6b96e-156">Testleri Çalıştırma</span><span class="sxs-lookup"><span data-stu-id="6b96e-156">Running Tests</span></span>

<span data-ttu-id="6b96e-157">Visual Studio 2008 Professional (ve üstü sürümleri) IDE içinden Visual Studio birim testi projelerini çalıştırmak için kullanılan bir yerleşik test Çalıştırıcısı içerir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-157">Visual Studio 2008 Professional (and higher editions) includes a built-in test runner that can be used to run Visual Studio Unit Test projects within the IDE.</span></span> <span data-ttu-id="6b96e-158">Biz seçebilirsiniz **Test -&gt;Çalıştır -&gt;Çözümdeki tüm testleri** menü komutu (veya tür Ctrl R A) tüm bizim birim testleri çalıştırmak için.</span><span class="sxs-lookup"><span data-stu-id="6b96e-158">We can select the **Test-&gt;Run-&gt;All Tests in Solution** menu command (or type Ctrl R, A) to run all of our unit tests.</span></span> <span data-ttu-id="6b96e-159">Veya alternatif olarak size belirli test sınıfı veya test yöntemi içinde bizim imleç Konumlandır ve gerçekleştirebilirsiniz **Test -&gt;Çalıştır -&gt;testleri geçerli bağlamda** birim testleri kümesini çalıştırmak için komutu (veya Ctrl R T türü).</span><span class="sxs-lookup"><span data-stu-id="6b96e-159">Or alternatively we can position our cursor within a specific test class or test method and use the **Test-&gt;Run-&gt;Tests in Current Context** menu command (or type Ctrl R, T) to run a subset of the unit tests.</span></span>

<span data-ttu-id="6b96e-160">Şimdi DinnerTest sınıfı içinde bizim imleç Konumlandır ve biz yalnızca tanımlı Çalıştır iki testleri için "Ctrl R, T" yazın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-160">Let's position our cursor within the DinnerTest class and type "Ctrl R, T" to run the two tests we just defined.</span></span> <span data-ttu-id="6b96e-161">Bunu, "Test Sonuçları" penceresi Visual Studio içinde görünür ve içinde listelenen bizim testi sonuçlarını göreceğiz:</span><span class="sxs-lookup"><span data-stu-id="6b96e-161">When we do this a "Test Results" window will appear within Visual Studio and we'll see the results of our test run listed within it:</span></span>

![](enable-automated-unit-testing/_static/image5.png)

<span data-ttu-id="6b96e-162">*Not: VS test sonuçları penceresi sınıf adı sütun varsayılan olarak göstermez. Bu Test Sonuçları penceresi içinde sağ tıklayarak ve Sütun Ekle/Kaldır menüsünü komutunu kullanarak ekleyebilirsiniz.*</span><span class="sxs-lookup"><span data-stu-id="6b96e-162">*Note: The VS test results window does not show the Class Name column by default. You can add this by right-clicking within the Test Results window and using the Add/Remove Columns menu command.*</span></span>

<span data-ttu-id="6b96e-163">Yalnızca bir saniyenin Çalıştır – ve siz iki testlerimizde sürdü her ikisi de geçirilen bakın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-163">Our two tests took only a fraction of a second to run – and as you can see they both passed.</span></span> <span data-ttu-id="6b96e-164">Biz şimdi geçin ve iki yardımcı yöntemler - IsUserHost() ve Yemeği sınıfına eklediğimiz IsUserRegisterd() – kapak yanı sıra belirli kural doğrulamaları doğrulayın Ek testler oluşturarak kullanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-164">We can now go on and augment them by creating additional tests that verify specific rule validations, as well as cover the two helper methods - IsUserHost() and IsUserRegisterd() – that we added to the Dinner class.</span></span> <span data-ttu-id="6b96e-165">Tüm bu testleri Yemeği sınıfı için yerinde olması, çok daha kolay ve yeni iş kurallarını ve doğrulamaları gelecekte eklemek daha güvenli hale getirir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-165">Having all these tests in place for the Dinner class will make it much easier and safer to add new business rules and validations to it in the future.</span></span> <span data-ttu-id="6b96e-166">Biz bizim yeni kural mantığı için yemeği ekleyin ve onu bizim önceki mantığı işlevlerden herhangi birini bozuk taşınmadığından emin saniye içinde doğrulayın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-166">We can add our new rule logic to Dinner, and then within seconds verify that it hasn't broken any of our previous logic functionality.</span></span>

<span data-ttu-id="6b96e-167">Nasıl bir açıklayıcı test adını kullanarak hızlı bir şekilde ne her test doğruluyor anlamak kolaylaştırır dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="6b96e-167">Notice how using a descriptive test name makes it easy to quickly understand what each test is verifying.</span></span> <span data-ttu-id="6b96e-168">Kullanmanızı öneririz **Araçları -&gt;seçenekleri** menü komutu, Test Araçları - açma&gt;Test yürütme yapılandırma ekranında ve denetimi "başarısız veya yetersiz Birim test sonucu çift görüntüler Test hata noktası"onay kutusu.</span><span class="sxs-lookup"><span data-stu-id="6b96e-168">I recommend using the **Tools-&gt;Options** menu command, opening the Test Tools-&gt;Test Execution configuration screen, and checking the "Double-clicking a failed or inconclusive unit test result displays the point of failure in the test" checkbox.</span></span> <span data-ttu-id="6b96e-169">Bu, test sonuçları penceresi bir hata çift tıklayın ve hemen assert hatası atlamak olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-169">This will allow you to double-click on a failure in the test results window and jump immediately to the assert failure.</span></span>

### <a name="creating-dinnerscontroller-unit-tests"></a><span data-ttu-id="6b96e-170">DinnersController birim testleri oluşturma</span><span class="sxs-lookup"><span data-stu-id="6b96e-170">Creating DinnersController Unit Tests</span></span>

<span data-ttu-id="6b96e-171">Şimdi bizim DinnersController işlevselliğini doğrulayın bazı Birim testleri oluşturalım.</span><span class="sxs-lookup"><span data-stu-id="6b96e-171">Let's now create some unit tests that verify our DinnersController functionality.</span></span> <span data-ttu-id="6b96e-172">Biz Test Projemizin içinde "Denetleyicileri" klasörüne sağ tıklayarak ve ardından **Ekle -&gt;Yeni Test** menü komutu.</span><span class="sxs-lookup"><span data-stu-id="6b96e-172">We'll start by right-clicking on the "Controllers" folder within our Test project and then choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="6b96e-173">Biz "Birim testi" oluşturacak ve "DinnersControllerTest.cs" olarak adlandırın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-173">We'll create a "Unit Test" and name it "DinnersControllerTest.cs".</span></span>

<span data-ttu-id="6b96e-174">DinnersController Details() eylem yöntemine doğrulayın iki test yöntemleri oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="6b96e-174">We'll create two test methods that verify the Details() action method on the DinnersController.</span></span> <span data-ttu-id="6b96e-175">İlk varolan Yemeği istendiğinde bir görünümü döndürülür doğrular.</span><span class="sxs-lookup"><span data-stu-id="6b96e-175">The first will verify that a View is returned when an existing Dinner is requested.</span></span> <span data-ttu-id="6b96e-176">İkincisi, mevcut olmayan Yemeği istendiğinde "Bulunamadı" görünümü döndürülür doğrular:</span><span class="sxs-lookup"><span data-stu-id="6b96e-176">The second will verify that a "NotFound" view is returned when a non-existent Dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

<span data-ttu-id="6b96e-177">Yukarıdaki kod temiz derler.</span><span class="sxs-lookup"><span data-stu-id="6b96e-177">The above code compiles clean.</span></span> <span data-ttu-id="6b96e-178">Biz testlerini çalıştırdığınızda, ancak her ikisi de başarısız olur:</span><span class="sxs-lookup"><span data-stu-id="6b96e-178">When we run the tests, though, they both fail:</span></span>

![](enable-automated-unit-testing/_static/image6.png)

<span data-ttu-id="6b96e-179">Şu hata iletileri bakarsanız, bizim DinnersRepository sınıfı bir veritabanına bağlanmak çünkü testler başarısız neden olduğunu göreceğiz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-179">If we look at the error messages, we'll see that the reason the tests failed was because our DinnersRepository class was unable to connect to a database.</span></span> <span data-ttu-id="6b96e-180">NerdDinner uygulamamız \App altında bulunan bir yerel SQL Server Express dosyasına bir bağlantı dizesi kullanarak\_NerdDinner uygulama projesi veri dizini.</span><span class="sxs-lookup"><span data-stu-id="6b96e-180">Our NerdDinner application is using a connection-string to a local SQL Server Express file which lives under the \App\_Data directory of the NerdDinner application project.</span></span> <span data-ttu-id="6b96e-181">NerdDinner.Tests Projemizin derler ve farklı bir dizinde uygulama projesi çalıştırır çünkü bizim bağlantı dizesi göreli yol konumunu doğru değil.</span><span class="sxs-lookup"><span data-stu-id="6b96e-181">Because our NerdDinner.Tests project compiles and runs in a different directory then the application project, the relative path location of our connection-string is incorrect.</span></span>

<span data-ttu-id="6b96e-182">Biz *verebilir* bizim test projesi için SQL Express veritabanı dosyası kopyalayarak bu sorunu gidermek ve ardından bir uygun test bağlantı dizesi test Projemizin App.config dosyasında ekleyin.</span><span class="sxs-lookup"><span data-stu-id="6b96e-182">We *could* fix this by copying the SQL Express database file to our test project, and then add an appropriate test connection-string to it in the App.config of our test project.</span></span> <span data-ttu-id="6b96e-183">Bu, yukarıdaki testleri engeli kaldırılmış ve çalıştırma almalıdır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-183">This would get the above tests unblocked and running.</span></span>

<span data-ttu-id="6b96e-184">Birim testi gerçek bir veritabanı kullanarak kod yine de onunla belirli zorluklar getirir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-184">Unit testing code using a real database, though, brings with it a number of challenges.</span></span> <span data-ttu-id="6b96e-185">Özellikle:</span><span class="sxs-lookup"><span data-stu-id="6b96e-185">Specifically:</span></span>

- <span data-ttu-id="6b96e-186">Ayrıca birim testleri yürütme süresini önemli ölçüde yavaşlatır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-186">It significantly slows down the execution time of unit tests.</span></span> <span data-ttu-id="6b96e-187">Artık, sık yürütülecek erişememeleri testleri çalıştırmak için alır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-187">The longer it takes to run tests, the less likely you are to execute them frequently.</span></span> <span data-ttu-id="6b96e-188">İdeal olan, saniye cinsinden – çalıştırılması ve onu bir şey yapmanız projesi derleme olarak doğal olarak olması için birim testleri istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-188">Ideally you want your unit tests to be able to be run in seconds – and have it be something you do as naturally as compiling the project.</span></span>
- <span data-ttu-id="6b96e-189">Testleri içindeki Kurulum ve temizleme mantığı karmaşıklaştırır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-189">It complicates the setup and cleanup logic within tests.</span></span> <span data-ttu-id="6b96e-190">Her birim testi yalıtılmış ve diğerleri (hiçbir yan etkileri veya bağımlılıkları ile) bağımsız olmasını istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-190">You want each unit test to be isolated and independent of others (with no side effects or dependencies).</span></span> <span data-ttu-id="6b96e-191">Gerçek bir veritabanıyla çalışırken durumunu oluşturduğunu ve testleri arasında sıfırlamak gerekmez.</span><span class="sxs-lookup"><span data-stu-id="6b96e-191">When working against a real database you have to be mindful of state and reset it between tests.</span></span>

<span data-ttu-id="6b96e-192">"Bize bu sorunları çözmenin ve bizim testleriyle gerçek bir veritabanını kullanmak için gereken önlemenize yardımcı olabilir bağımlılık ekleme" adlı bir tasarım deseni bakalım.</span><span class="sxs-lookup"><span data-stu-id="6b96e-192">Let's look at a design pattern called "dependency injection" that can help us work around these issues and avoid the need to use a real database with our tests.</span></span>

### <a name="dependency-injection"></a><span data-ttu-id="6b96e-193">Bağımlılık ekleme</span><span class="sxs-lookup"><span data-stu-id="6b96e-193">Dependency Injection</span></span>

<span data-ttu-id="6b96e-194">Şu anda DinnersController sıkı şekilde "DinnerRepository sınıfına bağlı".</span><span class="sxs-lookup"><span data-stu-id="6b96e-194">Right now DinnersController is tightly "coupled" to the DinnerRepository class.</span></span> <span data-ttu-id="6b96e-195">"Kuplaj" Burada bir sınıf açıkça başka bir sınıf üzerinde çalışması için bağımlı bir durum başvuruyor:</span><span class="sxs-lookup"><span data-stu-id="6b96e-195">"Coupling" refers to a situation where a class explicitly relies on another class in order to work:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

<span data-ttu-id="6b96e-196">DinnerRepository sınıfı bir veritabanına erişim gerektirdiğinden, sıkı şekilde bağlı bağımlılık DinnersController sınıfı bir veritabanı sınanacak DinnersController eylem yöntemleri yapılabilmesi için bize gerektiren yukarı DinnerRepository ucunda sahiptir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-196">Because the DinnerRepository class requires access to a database, the tightly coupled dependency the DinnersController class has on the DinnerRepository ends up requiring us to have a database in order for the DinnersController action methods to be tested.</span></span>

<span data-ttu-id="6b96e-197">Biz bu sorunu "bağımlılıkları (ör. veri erişimi sağlayan sınıflar depo) artık dolaylı olarak, bunları kullanan sınıfları içinde oluşturulduğu bir yaklaşım olan bağımlılık ekleme" – adlı bir tasarım desenini kullanarak elde edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-197">We can get around this by employing a design pattern called "dependency injection" – which is an approach where dependencies (like repository classes that provide data access) are no longer implicitly created within classes that use them.</span></span> <span data-ttu-id="6b96e-198">Bunun yerine, bağımlılıkları açıkça bunları kullanan sınıfına geçirilebilir oluşturucu bağımsız değişkenleri kullanma.</span><span class="sxs-lookup"><span data-stu-id="6b96e-198">Instead, dependencies can be explicitly passed to the class that uses them using constructor arguments.</span></span> <span data-ttu-id="6b96e-199">Bağımlılıkları arabirimleri kullanarak tanımlanmışsa, biz sonra birim sınama senaryolarını için "sahte" bağımlılık uygulamalarında geçirmek için esnekliğine sahip olursunuz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-199">If the dependencies are defined using interfaces, we then have the flexibility to pass in "fake" dependency implementations for unit test scenarios.</span></span> <span data-ttu-id="6b96e-200">Bu, aslında bir veritabanına erişimi gerektirmez test özgü bağımlılık uygulamaları oluşturmak için bize sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b96e-200">This enables us to create test-specific dependency implementations that do not actually require access to a database.</span></span>

<span data-ttu-id="6b96e-201">Bu eylem görmek için şimdi bağımlılık ekleme bizim DinnersController ile uygulayın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-201">To see this in action, let's implement dependency injection with our DinnersController.</span></span>

#### <a name="extracting-an-idinnerrepository-interface"></a><span data-ttu-id="6b96e-202">IDinnerRepository arabirim ayıklanıyor</span><span class="sxs-lookup"><span data-stu-id="6b96e-202">Extracting an IDinnerRepository interface</span></span>

<span data-ttu-id="6b96e-203">Bizim ilk adım, almak ve azalma güncelleştirmek için bizim denetleyicileri gerektiren deposu sözleşme yalıtan yeni bir IDinnerRepository arabirimi oluşturmak üzere olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-203">Our first step will be to create a new IDinnerRepository interface that encapsulates the repository contract our controllers require to retrieve and update Dinners.</span></span>

<span data-ttu-id="6b96e-204">Biz bu arabirimi sözleşme el ile \Models klasöre sağ tıklayarak ve ardından seçme tanımlayabilirsiniz **Ekle -&gt;yeni öğe** menü komutu ve IDinnerRepository.cs adlı yeni bir arabirim oluşturma.</span><span class="sxs-lookup"><span data-stu-id="6b96e-204">We can define this interface contract manually by right-clicking on the \Models folder, and then choosing the **Add-&gt;New Item** menu command and creating a new interface named IDinnerRepository.cs.</span></span>

<span data-ttu-id="6b96e-205">Alternatif olarak biz araçları yerleşik-Visual Studio Professional (ve üstü sürümleri) için otomatik olarak yeniden düzenleme extract kullanın ve arabirim bize bizim varolan bir DinnerRepository sınıftan oluşturun.</span><span class="sxs-lookup"><span data-stu-id="6b96e-205">Alternatively we can use the refactoring tools built-into Visual Studio Professional (and higher editions) to automatically extract and create an interface for us from our existing DinnerRepository class.</span></span> <span data-ttu-id="6b96e-206">VS kullanarak bu arabirimi ayıklamak için yalnızca DinnerRepository sınıfında metin düzenleyicisinde imleci getirin ve ardından sağ tıklatın ve seçin **düzenleme -&gt;arayüz** menü komutu:</span><span class="sxs-lookup"><span data-stu-id="6b96e-206">To extract this interface using VS, simply position the cursor in the text editor on the DinnerRepository class, and then right-click and choose the **Refactor-&gt;Extract Interface** menu command:</span></span>

![](enable-automated-unit-testing/_static/image7.png)

<span data-ttu-id="6b96e-207">Bu "Extract arabirimi" iletişim kutusunu başlatın ve bize oluşturmak için arabirimi adı ister.</span><span class="sxs-lookup"><span data-stu-id="6b96e-207">This will launch the "Extract Interface" dialog and prompt us for the name of the interface to create.</span></span> <span data-ttu-id="6b96e-208">Bu IDinnerRepository için varsayılan ve otomatik olarak eklemek için var olan DinnerRepository sınıfındaki tüm genel yöntemler seçin:</span><span class="sxs-lookup"><span data-stu-id="6b96e-208">It will default to IDinnerRepository and automatically select all public methods on the existing DinnerRepository class to add to the interface:</span></span>

![](enable-automated-unit-testing/_static/image8.png)

<span data-ttu-id="6b96e-209">Biz "Tamam" düğmesine tıkladığınızda, Visual Studio uygulamamız için yeni bir IDinnerRepository arabirimi ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6b96e-209">When we click the "ok" button, Visual Studio will add a new IDinnerRepository interface to our application:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

<span data-ttu-id="6b96e-210">Ve böylece arabirimini uygulayan bizim varolan DinnerRepository sınıfı güncelleştirildi:</span><span class="sxs-lookup"><span data-stu-id="6b96e-210">And our existing DinnerRepository class will be updated so that it implements the interface:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a><span data-ttu-id="6b96e-211">Oluşturucu ekleme desteklemek için DinnersController güncelleştiriliyor</span><span class="sxs-lookup"><span data-stu-id="6b96e-211">Updating DinnersController to support constructor injection</span></span>

<span data-ttu-id="6b96e-212">Şimdi yeni arabirimi kullanmak üzere DinnersController sınıfı güncelleştiriyoruz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-212">We'll now update the DinnersController class to use the new interface.</span></span>

<span data-ttu-id="6b96e-213">Şu anda DinnersController "dinnerRepository" alanı her zaman DinnerRepository sınıftır şekilde kodlanmış:</span><span class="sxs-lookup"><span data-stu-id="6b96e-213">Currently DinnersController is hard-coded such that its "dinnerRepository" field is always a DinnerRepository class:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

<span data-ttu-id="6b96e-214">"DinnerRepository" alan türü DinnerRepository yerine IDinnerRepository böylece biz değiştireceksiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-214">We'll change it so that the "dinnerRepository" field is of type IDinnerRepository instead of DinnerRepository.</span></span> <span data-ttu-id="6b96e-215">İki ortak DinnersController oluşturucular sonra ekleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-215">We'll then add two public DinnersController constructors.</span></span> <span data-ttu-id="6b96e-216">Oluşturuculardan birine bir IDinnerRepository bağımsız değişken olarak geçirilen sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b96e-216">One of the constructors allows an IDinnerRepository to be passed as an argument.</span></span> <span data-ttu-id="6b96e-217">Diğer mevcut bizim DinnerRepository uygulamanızı kullanan varsayılan bir oluşturucu şöyledir:</span><span class="sxs-lookup"><span data-stu-id="6b96e-217">The other is a default constructor that uses our existing DinnerRepository implementation:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

<span data-ttu-id="6b96e-218">Varsayılan olarak ASP.NET MVC denetleyicisi sınıfları varsayılan oluşturucular kullanma oluşturduğundan, çalışma zamanında bizim DinnersController veri erişimi gerçekleştirdiği DinnerRepository sınıfı kullanmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="6b96e-218">Because ASP.NET MVC by default creates controller classes using default constructors, our DinnersController at runtime will continue to use the DinnerRepository class to perform data access.</span></span>

<span data-ttu-id="6b96e-219">Bir "sahte" Yemeği deposu uygulaması parametre Oluşturucusu kullanarak geçirmek için biz yine de bizim birim testleri şimdi güncelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-219">We can now update our unit tests, though, to pass in a "fake" dinner repository implementation using the parameter constructor.</span></span> <span data-ttu-id="6b96e-220">Bu "sahte" Yemeği depo gerçek bir veritabanına erişimi gerektirmez ve bunun yerine bellek içi örnek verileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-220">This "fake" dinner repository will not require access to a real database, and instead will use in-memory sample data.</span></span>

#### <a name="creating-the-fakedinnerrepository-class"></a><span data-ttu-id="6b96e-221">FakeDinnerRepository sınıfı oluşturma</span><span class="sxs-lookup"><span data-stu-id="6b96e-221">Creating the FakeDinnerRepository class</span></span>

<span data-ttu-id="6b96e-222">FakeDinnerRepository sınıfını oluşturalım.</span><span class="sxs-lookup"><span data-stu-id="6b96e-222">Let's create a FakeDinnerRepository class.</span></span>

<span data-ttu-id="6b96e-223">Biz NerdDinner.Tests Projemizin "Fakes" dizininde oluşturarak başlayın ve yeni bir FakeDinnerRepository sınıf ekleme (klasörü sağ tıklatın ve seçin **Ekle -&gt;yeni sınıf**):</span><span class="sxs-lookup"><span data-stu-id="6b96e-223">We'll begin by creating a "Fakes" directory within our NerdDinner.Tests project and then add a new FakeDinnerRepository class to it (right-click on the folder and choose **Add-&gt;New Class**):</span></span>

![](enable-automated-unit-testing/_static/image9.png)

<span data-ttu-id="6b96e-224">Böylece FakeDinnerRepository sınıfı IDinnerRepository arabirimini uygulayan kod güncelleştiriyoruz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-224">We'll update the code so that the FakeDinnerRepository class implements the IDinnerRepository interface.</span></span> <span data-ttu-id="6b96e-225">Biz sonra üzerinde sağ tıklatın ve "Uygulama arabirimi IDinnerRepository" bağlam menüsü komutu seçin:</span><span class="sxs-lookup"><span data-stu-id="6b96e-225">We can then right-click on it and choose the "Implement interface IDinnerRepository" context menu command:</span></span>

![](enable-automated-unit-testing/_static/image10.png)

<span data-ttu-id="6b96e-226">Bu, otomatik olarak IDinnerRepository arabirimi üyelerin tümünü bizim FakeDinnerRepository sınıfı varsayılan "saplama" uygulamaları ile eklemek Visual Studio neden olur:</span><span class="sxs-lookup"><span data-stu-id="6b96e-226">This will cause Visual Studio to automatically add all of the IDinnerRepository interface members to our FakeDinnerRepository class with default "stub out" implementations:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

<span data-ttu-id="6b96e-227">Biz bir bellek içi listesi dışına çalışmaya FakeDinnerRepository uygulama sonra güncelleştirebilirsiniz&lt;Yemeği&gt; koleksiyonu geçirilen kendisine oluşturucu bağımsız değişkeni olarak:</span><span class="sxs-lookup"><span data-stu-id="6b96e-227">We can then update the FakeDinnerRepository implementation to work off of an in-memory List&lt;Dinner&gt; collection passed to it as a constructor argument:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

<span data-ttu-id="6b96e-228">Şimdi bir veritabanı gerektirmez ve bunun yerine Yemeği nesneleri bir bellek içi listesi çalışabilirsiniz sahte bir IDinnerRepository uygulaması sahibiz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-228">We now have a fake IDinnerRepository implementation that does not require a database, and can instead work off an in-memory list of Dinner objects.</span></span>

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a><span data-ttu-id="6b96e-229">FakeDinnerRepository birim testleri ile kullanma</span><span class="sxs-lookup"><span data-stu-id="6b96e-229">Using the FakeDinnerRepository with Unit Tests</span></span>

<span data-ttu-id="6b96e-230">Şimdi veritabanı kullanılabilir durumda olduğundan, daha önce başarısız DinnersController birim testleri döndür.</span><span class="sxs-lookup"><span data-stu-id="6b96e-230">Let's return to the DinnersController unit tests that failed earlier because the database wasn't available.</span></span> <span data-ttu-id="6b96e-231">Size örnek verilerle bellek içi Yemeği aşağıdaki kodu kullanarak DinnersController için doldurulan bir FakeDinnerRepository kullanılacak test yöntemleri güncelleştirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="6b96e-231">We can update the test methods to use a FakeDinnerRepository populated with sample in-memory Dinner data to the DinnersController using the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

<span data-ttu-id="6b96e-232">Ve her ikisi de şimdi Biz bu testleri çalıştırdığınızda geçirin:</span><span class="sxs-lookup"><span data-stu-id="6b96e-232">And now when we run these tests they both pass:</span></span>

![](enable-automated-unit-testing/_static/image11.png)

<span data-ttu-id="6b96e-233">En önemlisi, bunlar yalnızca bir saniyenin çalıştırmak için ayırın ve herhangi bir karmaşık kurulum/temizleme mantık gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="6b96e-233">Best of all, they take only a fraction of a second to run, and do not require any complicated setup/cleanup logic.</span></span> <span data-ttu-id="6b96e-234">Birim testi şimdi tüm (dahil olmak üzere liste, ayrıntı, disk belleği, oluşturma, güncelleştirme ve silme) DinnersController eylem yöntemi kodumuza gerçek bir veritabanına bağlanmak hiç gerek kalmadan geçebiliriz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-234">We can now unit test all of our DinnersController action method code (including listing, paging, details, create, update and delete) without ever needing to connect to a real database.</span></span>

| <span data-ttu-id="6b96e-235">**Yan konu: Bağımlılık ekleme çerçeveler**</span><span class="sxs-lookup"><span data-stu-id="6b96e-235">**Side Topic: Dependency Injection Frameworks**</span></span> |
| --- |
| <span data-ttu-id="6b96e-236">(Yukarıda duyuyoruz gibi) el ile bağımlılık ekleme gerçekleştirme düzgün çalışır, ancak bağımlılık sayısı korumak daha zor hale ve uygulama bileşenleri artırır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-236">Performing manual dependency injection (like we are above) works fine, but does become harder to maintain as the number of dependencies and components in an application increases.</span></span> <span data-ttu-id="6b96e-237">Birkaç bağımlılık ekleme çerçeveleri daha da fazla bağımlılık Yönetimi esneklik sağlanmasına yardımcı olabilecek .NET için mevcut.</span><span class="sxs-lookup"><span data-stu-id="6b96e-237">Several dependency injection frameworks exist for .NET that can help provide even more dependency management flexibility.</span></span> <span data-ttu-id="6b96e-238">Bazen "Ters çevirmeyi denetim" (IOC) kapsayıcı olarak adlandırılan bu çerçeveleri belirtme ve (çoğunlukla Oluşturucu ekleme kullanarak çalışma zamanında nesnelere bağımlılıkları geçirme için yapılandırma desteği, ek bir düzeyi sağlayan mekanizmalar ).</span><span class="sxs-lookup"><span data-stu-id="6b96e-238">These frameworks, also sometimes called "Inversion of Control" (IoC) containers, provide mechanisms that enable an additional level of configuration support for specifying and passing dependencies to objects at runtime (most often using constructor injection).</span></span> <span data-ttu-id="6b96e-239">Bazı daha popüler OSS bağımlılık ekleme / .NET içinde IOC çerçeve içerir: AutoFac, Ninject, Spring.NET, StructureMap ve Windsor.</span><span class="sxs-lookup"><span data-stu-id="6b96e-239">Some of the more popular OSS Dependency Injection / IOC frameworks in .NET include: AutoFac, Ninject, Spring.NET, StructureMap, and Windsor.</span></span> <span data-ttu-id="6b96e-240">ASP.NET MVC sunan genişletilebilirlik çözümleme ve örnek oluşturma denetleyicilerinin katılacak şekilde geliştiriciler etkinleştirmek ve bağımlılık ekleme sağlayan API'leri / bu işlemi içinde düzgün bir şekilde tümleştirilecek şekilde IOC çerçeveleri.</span><span class="sxs-lookup"><span data-stu-id="6b96e-240">ASP.NET MVC exposes extensibility APIs that enable developers to participate in the resolution and instantiation of controllers, and which enables Dependency Injection / IoC frameworks to be cleanly integrated within this process.</span></span> <span data-ttu-id="6b96e-241">DI/IOC framework kullanarak bize ve DinnerRepositorys arasındaki ilişki tamamen kaldırabilirsiniz bizim DinnersController – varsayılan oluşturucu kaldırmak da etkinleştirmeniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-241">Using a DI/IOC framework would also enable us to remove the default constructor from our DinnersController – which would completely remove the coupling between it and the DinnerRepositorys.</span></span> <span data-ttu-id="6b96e-242">Biz bağımlılık ekleme kullanılarak olmaz / NerdDinner uygulamamız IOC çerçevesiyle.</span><span class="sxs-lookup"><span data-stu-id="6b96e-242">We won't be using a dependency injection / IOC framework with our NerdDinner application.</span></span> <span data-ttu-id="6b96e-243">Ancak bir şey NerdDinner kod tabanlı ve yetenekleri büyüdü varsa geleceğe yönelik düşünün.</span><span class="sxs-lookup"><span data-stu-id="6b96e-243">But it is something we could consider for the future if the NerdDinner code-base and capabilities grew.</span></span> |

### <a name="creating-edit-action-unit-tests"></a><span data-ttu-id="6b96e-244">Düzen eylem birim testleri oluşturma</span><span class="sxs-lookup"><span data-stu-id="6b96e-244">Creating Edit Action Unit Tests</span></span>

<span data-ttu-id="6b96e-245">Şimdi DinnersController düzenleme işlevselliğini doğrulayın bazı Birim testleri oluşturalım.</span><span class="sxs-lookup"><span data-stu-id="6b96e-245">Let's now create some unit tests that verify the Edit functionality of the DinnersController.</span></span> <span data-ttu-id="6b96e-246">Bizim düzenleme eylem HTTP GET sürümü test ederek başlayacağız:</span><span class="sxs-lookup"><span data-stu-id="6b96e-246">We'll start by testing the HTTP-GET version of our Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

<span data-ttu-id="6b96e-247">Geri geçerli Yemeği istendiğinde DinnerFormViewModel nesnesi tarafından yedeklenen bir görünüm işlenmeden doğrular bir test oluşturacağız:</span><span class="sxs-lookup"><span data-stu-id="6b96e-247">We'll create a test that verifies that a View backed by a DinnerFormViewModel object is rendered back when a valid dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

<span data-ttu-id="6b96e-248">Biz testi çalıştırdığınızda, ancak biz Dinner.IsHostedBy() denetimi gerçekleştirmek için User.Identity.Name özelliğini düzenleme yöntemi eriştiğinde, bir null başvuru özel durum nedeniyle işlemin başarısız olduğunu bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-248">When we run the test, though, we'll find that it fails because a null reference exception is thrown when the Edit method accesses the User.Identity.Name property to perform the Dinner.IsHostedBy() check.</span></span>

<span data-ttu-id="6b96e-249">Denetleyici temel sınıfı kullanıcı nesnesindeki oturum açan kullanıcı hakkındaki ayrıntıları yalıtır ve çalışma zamanında denetleyicisi oluşturduğunda, ASP.NET MVC tarafından doldurulur.</span><span class="sxs-lookup"><span data-stu-id="6b96e-249">The User object on the Controller base class encapsulates details about the logged-in user, and is populated by ASP.NET MVC when it creates the controller at runtime.</span></span> <span data-ttu-id="6b96e-250">Bir web sunucusu ortamı dışında DinnersController test ettiğiniz olduğundan, kullanıcı nesnesi ayarlanmamış (Bu nedenle özel durum başvurusu null).</span><span class="sxs-lookup"><span data-stu-id="6b96e-250">Because we are testing the DinnersController outside of a web-server environment, the User object isn't set (hence the null reference exception).</span></span>

### <a name="mocking-the-useridentityname-property"></a><span data-ttu-id="6b96e-251">User.Identity.Name özelliği mocking</span><span class="sxs-lookup"><span data-stu-id="6b96e-251">Mocking the User.Identity.Name property</span></span>

<span data-ttu-id="6b96e-252">Mocking çerçeveleri bize dinamik olarak testlerimizde destek bağımlı nesneler sahte sürümleri oluşturmanıza olanak sağlayarak daha kolay test edin.</span><span class="sxs-lookup"><span data-stu-id="6b96e-252">Mocking frameworks make testing easier by enabling us to dynamically create fake versions of dependent objects that support our tests.</span></span> <span data-ttu-id="6b96e-253">Örneğin, biz mocking framework düzenleme eylem testimizde dinamik olarak bizim DinnersController sanal bir kullanıcı adı aramak için kullanabileceğiniz bir kullanıcı nesnesi oluşturmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-253">For example, we can use a mocking framework in our Edit action test to dynamically create a User object that our DinnersController can use to lookup a simulated username.</span></span> <span data-ttu-id="6b96e-254">Bu, biz bizim testi çalıştırdığınızda oluşturulan gelen bir null başvuru önlenmiş olur.</span><span class="sxs-lookup"><span data-stu-id="6b96e-254">This will avoid a null reference from being thrown when we run our test.</span></span>

<span data-ttu-id="6b96e-255">ASP.NET MVC ile kullanılan çerçeveler mocking birçok .NET vardır (listesini bunları burada görebilirsiniz: [ http://www.mockframeworks.com/ ](http://www.mockframeworks.com/)).</span><span class="sxs-lookup"><span data-stu-id="6b96e-255">There are many .NET mocking frameworks that can be used with ASP.NET MVC (you can see a list of them here: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span></span> <span data-ttu-id="6b96e-256">"Moq" adlı framework mocking bir açık kaynak kullanırız NerdDinner uygulamamızı test etmek için ücretsiz adresinden yüklenebilir [ http://www.mockframeworks.com/moq ](http://www.mockframeworks.com/moq).</span><span class="sxs-lookup"><span data-stu-id="6b96e-256">For testing our NerdDinner application we'll use an open source mocking framework called "Moq", which can be downloaded for free from [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span></span>

<span data-ttu-id="6b96e-257">Yüklendikten sonra bir başvuru NerdDinner.Tests Projemizin Moq.dll derlemeye ekleyeceğiz:</span><span class="sxs-lookup"><span data-stu-id="6b96e-257">Once downloaded, we'll add a reference in our NerdDinner.Tests project to the Moq.dll assembly:</span></span>

![](enable-automated-unit-testing/_static/image12.png)

<span data-ttu-id="6b96e-258">Ardından "CreateDinnersControllerAs(username)" yardımcı yöntemi, bir parametre ve hangi bir username alan sonra "DinnersController örneğinde User.Identity.Name özelliği mocks" bizim test sınıfına ekleyeceğiz:</span><span class="sxs-lookup"><span data-stu-id="6b96e-258">We'll then add a "CreateDinnersControllerAs(username)" helper method to our test class that takes a username as a parameter, and which then "mocks" the User.Identity.Name property on the DinnersController instance:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

<span data-ttu-id="6b96e-259">Moq (ASP.NET MVC denetleyicisi sınıflarına kullanıcı, istek, yanıt ve oturum gibi çalışma zamanı nesneleri kullanıma sunmak için başarılı) bir ControllerContext nesne fakes Mock nesnesi oluşturmak için yukarıdaki kullanıyoruz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-259">Above we are using Moq to create a Mock object that fakes a ControllerContext object (which is what ASP.NET MVC passes to Controller classes to expose runtime objects like User, Request, Response, and Session).</span></span> <span data-ttu-id="6b96e-260">ControllerContext HttpContext.User.Identity.Name özellikte size yardımcı yönteme geçirilen username dizesi döndürmesi gerektiğini belirtmek için Mock biz "SetupGet" metodunun çağrılması.</span><span class="sxs-lookup"><span data-stu-id="6b96e-260">We are calling the "SetupGet" method on the Mock to indicate that the HttpContext.User.Identity.Name property on ControllerContext should return the username string we passed to the helper method.</span></span>

<span data-ttu-id="6b96e-261">Biz ControllerContext özellikleri ve yöntemleri herhangi bir sayıda mock.</span><span class="sxs-lookup"><span data-stu-id="6b96e-261">We can mock any number of ControllerContext properties and methods.</span></span> <span data-ttu-id="6b96e-262">Bunu göstermek için ı SetupGet() çağrısı (hangi aşağıdaki – testler için gerçekten gerekli değildir ancak istek özellikleri nasıl mock göstermeye yardımcı olan) Request.IsAuthenticated özelliği için de ekledik.</span><span class="sxs-lookup"><span data-stu-id="6b96e-262">To illustrate this I've also added a SetupGet() call for the Request.IsAuthenticated property (which isn't actually needed for the tests below – but which helps illustrate how you can mock Request properties).</span></span> <span data-ttu-id="6b96e-263">Biz bittiğinde biz bizim yardımcı yöntemini döndürür DinnersController ControllerContext mock örneği atayın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-263">When we are done we assign an instance of the ControllerContext mock to the DinnersController our helper method returns.</span></span>

<span data-ttu-id="6b96e-264">Biz şimdi farklı kullanıcılar içeren düzenleme senaryoları test etmek için bu yardımcı yöntemini kullanan birim testleri yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="6b96e-264">We can now write unit tests that use this helper method to test Edit scenarios involving different users:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

<span data-ttu-id="6b96e-265">Ve şimdi biz testleri çalıştırdığınızda geçirirler:</span><span class="sxs-lookup"><span data-stu-id="6b96e-265">And now when we run the tests they pass:</span></span>

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a><span data-ttu-id="6b96e-266">Test UpdateModel() senaryoları</span><span class="sxs-lookup"><span data-stu-id="6b96e-266">Testing UpdateModel() scenarios</span></span>

<span data-ttu-id="6b96e-267">Düzen eylem HTTP GET sürümü kapak testleri oluşturduk.</span><span class="sxs-lookup"><span data-stu-id="6b96e-267">We've created tests that cover the HTTP-GET version of the Edit action.</span></span> <span data-ttu-id="6b96e-268">Şimdi düzenle eylem HTTP POST sürümünü doğrulamak bazı testleri oluşturalım:</span><span class="sxs-lookup"><span data-stu-id="6b96e-268">Let's now create some tests that verify the HTTP-POST version of the Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

<span data-ttu-id="6b96e-269">İlginç yeni test bize Bu eylem yöntemine desteklemek kullanım denetleyicisi temel sınıf UpdateModel() yardımcı yönteminin senaryodur.</span><span class="sxs-lookup"><span data-stu-id="6b96e-269">The interesting new testing scenario for us to support with this action method is its usage of the UpdateModel() helper method on the Controller base class.</span></span> <span data-ttu-id="6b96e-270">Form gönderme değerleri bizim Yemeği nesne örneğine bağlamak için bu yardımcı yöntem kullanıyoruz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-270">We are using this helper method to bind form-post values to our Dinner object instance.</span></span>

<span data-ttu-id="6b96e-271">Aşağıda, biz UpdateModel() yardımcı yöntemini kullanmak üzere değerlerini gönderilen form nasıl sağlayabilir gösteren iki testleri verilmektedir.</span><span class="sxs-lookup"><span data-stu-id="6b96e-271">Below are two tests that demonstrates how we can supply form posted values for the UpdateModel() helper method to use.</span></span> <span data-ttu-id="6b96e-272">Biz oluşturma ve FormCollection nesne doldurma bunu ve denetleyicisinde "ValueProvider" özelliği atayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-272">We'll do this by creating and populating a FormCollection object, and then assign it to the "ValueProvider" property on the Controller.</span></span>

<span data-ttu-id="6b96e-273">İlk testi başarılı kaydetme işleminde Ayrıntılar eylemi tarayıcının yönlendirildiği doğrular.</span><span class="sxs-lookup"><span data-stu-id="6b96e-273">The first test verifies that on a successful save the browser is redirected to the details action.</span></span> <span data-ttu-id="6b96e-274">Geçersiz giriş gönderildiğinde eylemi bir hata iletisi ile yeniden düzenleme görünümü görüntüler ikinci test doğrular.</span><span class="sxs-lookup"><span data-stu-id="6b96e-274">The second test verifies that when invalid input is posted the action redisplays the edit view again with an error message.</span></span>


[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a><span data-ttu-id="6b96e-275">Wrap-Up test etme</span><span class="sxs-lookup"><span data-stu-id="6b96e-275">Testing Wrap-Up</span></span>

<span data-ttu-id="6b96e-276">Biz birim test denetleyicisi sınıflarda ilgili temel kavramlarını ele.</span><span class="sxs-lookup"><span data-stu-id="6b96e-276">We've covered the core concepts involved in unit testing controller classes.</span></span> <span data-ttu-id="6b96e-277">Biz bu teknikler kolayca yüzlerce uygulamamız davranışını doğrulayın basit test oluşturmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b96e-277">We can use these techniques to easily create hundreds of simple tests that verify the behavior of our application.</span></span>

<span data-ttu-id="6b96e-278">Bizim denetleyici ve model testleri gerçek bir veritabanı gerektirmediği için son derece hızlı ve kolay çalışır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-278">Because our controller and model tests do not require a real database, they are extremely fast and easy to run.</span></span> <span data-ttu-id="6b96e-279">Saniye cinsinden otomatikleştirilmiş testleri yüzlerce yürütün ve hemen olup olmadığını biz yapılan bir değişikliği bir şey ihlal için geri bildirim alma mümkün olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-279">We'll be able to execute hundreds of automated tests in seconds, and immediately get feedback as to whether a change we made broke something.</span></span> <span data-ttu-id="6b96e-280">Bu, bize sürekli, düzenleme, geliştirmek ve uygulamamızı iyileştirmek için güvenirlik sağlanmasına yardımcı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-280">This will help provide us the confidence to continually improve, refactor, and refine our application.</span></span>

<span data-ttu-id="6b96e-281">Sınama kapsanan olarak son konu bu bölümde – ancak test bir şey olmadığından bir geliştirme işleminin sonunda yapmanız gerekir!</span><span class="sxs-lookup"><span data-stu-id="6b96e-281">We covered testing as the last topic in this chapter – but not because testing is something you should do at the end of a development process!</span></span> <span data-ttu-id="6b96e-282">Tersine, otomatikleştirilmiş testleri geliştirme sürecinizde olabildiğince erken yazmalısınız.</span><span class="sxs-lookup"><span data-stu-id="6b96e-282">On the contrary, you should write automated tests as early as possible in your development process.</span></span> <span data-ttu-id="6b96e-283">Bunu yaptığınızda bu nedenle geliştirme gibi bağlarla uygulamanızın kullanım örneği senaryosu hakkında düşünün ve uygulamanızla tasarımı konusunda size rehberlik eder yardımcı anında geri bildirim katmanlama ve göz önünde Kuplaj temiz almak sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b96e-283">Doing so enables you to get immediate feedback as you develop, helps you think thoughtfully about your application's use case scenarios, and guides you to design your application with clean layering and coupling in mind.</span></span>

<span data-ttu-id="6b96e-284">Kitap sonraki bölümde, Test güdümlü geliştirme (TDD) ve ASP.NET MVC ile kullanma ele alınacaktır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-284">A later chapter in the book will discuss Test Driven Development (TDD), and how to use it with ASP.NET MVC.</span></span> <span data-ttu-id="6b96e-285">TDD bir yinelemeli kodlama elde edilen kodunuzu karşılayacağı testleri ilk Burada yazdığınız uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-285">TDD is an iterative coding practice where you first write the tests that your resulting code will satisfy.</span></span> <span data-ttu-id="6b96e-286">TDD ile her özellik hakkında uygulamak üzere olduğunuz işlevselliği doğrulayan test oluşturarak başlayın.</span><span class="sxs-lookup"><span data-stu-id="6b96e-286">With TDD you begin each feature by creating a test that verifies the functionality you are about to implement.</span></span> <span data-ttu-id="6b96e-287">Birim testi ilk yardımcı açıkça özellik ve nasıl onu çalışması gerektiği anladığınızdan emin olun yazma.</span><span class="sxs-lookup"><span data-stu-id="6b96e-287">Writing the unit test first helps ensure that you clearly understand the feature and how it is supposed to work.</span></span> <span data-ttu-id="6b96e-288">Test yazılır (ve başarısız olduğunu doğruladıktan sonra) bunu ardından uygulamak yalnızca gerçek işlevselliğini test doğrular.</span><span class="sxs-lookup"><span data-stu-id="6b96e-288">Only after the test is written (and you have verified that it fails) do you then implement the actual functionality the test verifies.</span></span> <span data-ttu-id="6b96e-289">Zaten nasıl özellik çalışması gerektiği, kullanım örneği zaman düşünmek için harcanan olduğundan daha iyi anlamak gereksinimlerine sahip olur ve onları uygulamak en iyi nasıl.</span><span class="sxs-lookup"><span data-stu-id="6b96e-289">Because you've already spent time thinking about the use case of how the feature is supposed to work, you will have a better understanding of the requirements and how best to implement them.</span></span> <span data-ttu-id="6b96e-290">Olup olmadığını test – yeniden çalıştırıp olarak anında geri bildirim alma uygulamasıyla bittiğinde özelliği düzgün çalışır.</span><span class="sxs-lookup"><span data-stu-id="6b96e-290">When you are done with the implementation you can re-run the test – and get immediate feedback as to whether the feature works correctly.</span></span> <span data-ttu-id="6b96e-291">Biz, daha fazla bölüm 10'daki TDD ele alacağız.</span><span class="sxs-lookup"><span data-stu-id="6b96e-291">We'll cover TDD more in Chapter 10.</span></span>

### <a name="next-step"></a><span data-ttu-id="6b96e-292">Sonraki adım</span><span class="sxs-lookup"><span data-stu-id="6b96e-292">Next Step</span></span>

<span data-ttu-id="6b96e-293">Bazı son kaydırma yorumları.</span><span class="sxs-lookup"><span data-stu-id="6b96e-293">Some final wrap up comments.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="6b96e-294">[Önceki](use-ajax-to-implement-mapping-scenarios.md)
> [sonraki](nerddinner-wrap-up.md)</span><span class="sxs-lookup"><span data-stu-id="6b96e-294">[Previous](use-ajax-to-implement-mapping-scenarios.md)
[Next](nerddinner-wrap-up.md)</span></span>
