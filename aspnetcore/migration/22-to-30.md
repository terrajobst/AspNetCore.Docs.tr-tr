---
title: ASP.NET Core 2,2 ' den 3,0 önizlemeye geçiş yapın
author: rick-anderson
description: ASP.NET Core 2,2 projesini ASP.NET Core 3,0 ' e geçirmeyi öğrenin.
ms.author: riande
ms.custom: mvc
ms.date: 09/16/2019
uid: migration/22-to-30
ms.openlocfilehash: ce16961c8a30ed4b905d5a20b2230fbde269a3ed
ms.sourcegitcommit: b1e480e1736b0fe0e4d8dce4a4cf5c8e47fc2101
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/19/2019
ms.locfileid: "71108052"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core 2,2 ' den 3,0 ' e geçiş yapın

[Scott Ade](https://github.com/scottaddie) ve [Rick Anderson](https://twitter.com/RickAndMSFT) tarafından

Bu makalede, mevcut bir ASP.NET Core 2,2 projesinin ASP.NET Core 3,0 ' e nasıl güncelleştirilmesi açıklanmaktadır.

## <a name="prerequisites"></a>Önkoşullar

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Mac için Visual Studio](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Proje dosyasını güncelleştirme

* [Hedef Framework bilinen adını (tfd)](/dotnet/standard/frameworks) şu şekilde `netcoreapp3.0`ayarlayın:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Her türlü `<PackageReference>` [Microsoft. aspnetcore. All](xref:fundamentals/metapackage) veya [Microsoft. aspnetcore. app](xref:fundamentals/metapackage-app) metapackage ' i kaldırın.

* [Microsoft. aspnetcore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) paketini kaldırın. `<PackageReference>`

* Uygulamanız [API Çözümleyicileri](xref:web-api/advanced/analyzers)kullanıyorsa, `<PackageReference>` [Microsoft. aspnetcore. Mvc. API. çözümleyiciler](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) paketi için tüm öğeleri kaldırın. .NET Core SDK bir parçası olarak gönderilen çözümleyici 'yi kullanmak için proje dosyanızı düzenleyin:

```xml
<PropertyGroup>
 <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
</PropertyGroup>
```

* `<PackageReference>` `3.0.0-preview5-19227-01`Paketler için `Version` kalanöğelerinözniteliğinigeçerliönizlemeyegüncelleştirin(`Microsoft.AspNetCore.*` Örneğin,).

  Bir paketin 3,0 sürümü yoksa, paket 3,0 ' de kullanım dışı bırakılmış olabilir. Bu paketlerin birçoğu bir `Microsoft.AspNetCore.App` parçasıdır ve tek tek başvurulmamalıdır. 3,0 ' de artık üretilmeyen paketlerin ön listesi için bkz. [3,0 (ASPNET/AspNetCore #3756) içindeki paylaşılan çerçeve derlemeleri için paketleri üretme](https://github.com/aspnet/AspNetCore/issues/3756). *Paylaşılan çerçeve* , makinede yüklü olan ve tarafından `Microsoft.AspNetCore.App`başvurulan derleme ( *. dll* dosyaları) kümesidir. Daha fazla bilgi için bkz. [paylaşılan çerçeve](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Birçok önemli bileşeni için derlemeler 3,0 ' den `Microsoft.AspNetCore.App` kaldırılmıştır. `<PackageReference>` [Microsoft. aspnetcore. app 3,0 (ASPNET/aspnetcore #3755) ' den kaldırılmakta olan derlemelerde](https://github.com/aspnet/AspNetCore/issues/3755)listelenen paketlerden API 'leri kullanıyorsanız, öğeleri ekleyin.

  Kaldırılan bileşenlerin örnekleri şunlardır:

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  ' Deki `Microsoft.AspNetCore.App` derleme gönderimi listesi sonlandırılmamıştır ve 3,0 RTM 'den önce değişecektir.

  Aşağıdaki kodu göz önünde bulundurun:

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  Yukarıdaki kodda çağrılan `Microsoft.AspNet.WebApi.Client`yöntemi'ye eklenmiştir. `ReadAsAsync` 3,0 'deki derleme sorununu çözmek için [Microsoft. Aspnet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet paketini yükler.

* [JSON.NET desteği](#jsonnet-support)ekleyin.

* Projeler varsayılan olarak ASP.NET Core 3,0 veya sonraki sürümlerde [işlem içi barındırma modeline](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) göre yapılır. İsteğe bağlı olarak, `<AspNetCoreHostingModel>` `InProcess`değeri proje dosyasındaki özelliği olarak kaldırabilirsiniz.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Yapılandırma

Kestrel yapılandırmasını ( `ConfigureWebHostDefaults` *program.cs*) tarafından sunulan Web ana bilgisayar oluşturucusuna geçirin:

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Uygulama Konağı ile `HostBuilder`el ile oluşturursa, içindeki `ConfigureWebHostDefaults`Web ana `UseKestrel` bilgisayar Oluşturucu üzerinde çağırın:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Bağlantı ara yazılımı bağlantı bağdaştırıcılarını değiştirir

Bağlantı bağdaştırıcıları (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) Kestrel 'ten kaldırılmıştır. Bağlantı bağdaştırıcılarını bağlantı ara yazılımı ile değiştirin. Bağlantı ara yazılımı, ASP.NET Core işlem hattındaki HTTP ara hattına benzerdir, ancak alt düzey bağlantılar için. HTTPS ve bağlantı günlüğü:

* Bağlantı bağdaştırıcılarından bağlantı ara yazılıma taşınmıştır.
* Bu uzantı yöntemleri ASP.NET Core önceki sürümlerinde olduğu gibi çalışır. 

Daha fazla bilgi için [Kestrel makalesinin ListenOptions. Protocols bölümünde TlsFilterConnectionHandler örneğine](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols)bakın.

### <a name="transport-abstractions-moved-and-made-public"></a>Taşıma soyutlamaları taşınır ve herkese açık hale getirilir

Kestrel aktarım katmanı, içinde `Connections.Abstractions`ortak bir arabirim olarak kullanıma sunuldu. Bu güncelleştirmelerin bir parçası olarak:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`ve ilişkili türler kaldırılmıştır.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>, taşıma seçeneklerine <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> taşındı.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>öğesinden <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>kaldırıldı.

Daha fazla bilgi için aşağıdaki GitHub kaynaklarına bakın:

* [İstemci/sunucu ağı soyutlamaları (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Yeni yatak odası dinleyicisi soyutlama ve yeniden Plat Kestrel for top (ASPNET/AspNetCore #10321) uygulayın](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel Istek artbilgisi üst bilgileri

ASP.NET Core önceki sürümlerini hedefleyen uygulamalar için:

* Kestrel istek üstbilgileri koleksiyonuna HTTP/1.1 öbekli treyler üstbilgileri ekler.
* İstek gövdesi uca okunduktan sonra Treyi kullanılabilir.

Bu, üst bilgiler ve tanıtımları arasındaki belirsizlik hakkında bazı kaygılara neden olur. bu nedenle, tanıtımları 3,0`RequestTrailerExtensions`içinde yeni bir koleksiyona () taşınmıştır.

HTTP/2 istek fragmanları:

* ASP.NET Core 2,2 ' de kullanılamaz.
* 3,0 ile `RequestTrailerExtensions`kullanılabilir.

Bu treylara erişmek için yeni istek uzantısı yöntemleri vardır. HTTP/1.1 ile olduğu gibi, istek gövdesi sonuna kadar okunduktan sonra treylerle erişilebilir.

3,0 sürümü için aşağıdaki `RequestTrailerExtensions` yöntemler kullanılabilir:

* `GetDeclaredTrailers`Gövdeden sonra `Trailer` beklenme tanıtımın listesini listeleyen istek üst bilgisini alır. &ndash;
* `SupportsTrailers`&ndash; İsteğin treyler üst bilgilerini almayı destekleyip desteklemediğini gösterir.
* `CheckTrailersAvailable`&ndash; İsteğin treyleri destekleyip desteklemediğini ve okunmaları için kullanılabilir olup olmadığını denetler. Bu denetim, okunması gereken tanıtımın olduğunu varsaymaz. Bu yöntem tarafından döndürülse bile `true` okunması gereken bir Treyi olmayabilir.
* `GetTrailer`&ndash; Yanıttan istenen sondaki üstbilgiyi alır. Çağrılmadan `SupportsTrailers` <xref:System.NotSupportedException> önce işaretleyin veya istek sondaki üstbilgileri desteklemiyorsa meydana gelebilir. `GetTrailer`

Daha fazla bilgi için bkz. [istek fragmanları ayrı bir koleksiyonda (ASPNET/AspNetCore #10410) yerleştirme](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO devre dışı

`AllowSynchronousIO`, ve `HttpReqeuest.Body.Read` `HttpResponse.Body.Write` gibizamanuyumluGÇAPI'lerinietkinleştirilirveya`Stream.Flush`devre dışı bırakır. Bu API 'Ler, uygulama kilitlenmelerine neden olan bir iş parçacığı kaynağıdır. 3,0 ' `AllowSynchronousIO` de varsayılan olarak devre dışıdır. Daha fazla bilgi için [Kestrel makalesindeki zaman uyumlu GÇ bölümüne](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io)bakın.

İle ilgili `AllowSynchronousIO` `ConfigureKestrel`seçenekleri etkinleştirmenin yanı sıra, zaman uyumlu GÇ geçici bir risk azaltma olarak istek başına temelinde da geçersiz kılınabilir:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Dispose içinde zaman uyumlu API <xref:System.IO.TextWriter> 'ler çağıran uygulamalarla veya diğer akışlarla ilgili sorun [](/dotnet/standard/garbage-collection/implementing-dispose)yaşıyorsanız, bunun yerine yeni <xref:System.IO.Stream.DisposeAsync*> API 'yi çağırın.

Daha fazla bilgi için, bkz. [tüm sunucularda [Duyuru] AllowSynchronousIO devre dışı (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Microsoft. AspNetCore. Server. Kestrel. https derlemesi kaldırıldı

ASP.NET Core 2,1 ' de, *Microsoft. AspNetCore. Server. Kestrel. https. dll* ' nin içeriği *Microsoft. aspnetcore. Server. Kestrel. Core. dll*' ye taşınmıştır. Bu, öznitelikleri kullanan `TypeForwardedTo` bir kırılmamış güncelleştirmedir. 3,0 için boş *Microsoft. AspNetCore. Server. Kestrel. https. dll* derlemesi (ve NuGet paketi) kaldırılmıştır.

[Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) ' ye başvuran kitaplıklar ASP.NET Core bağımlılıklarını 2,1 veya üzeri bir sürüme güncelleştirmemelidir.

ASP.NET Core 2,1 veya sonraki bir sürümü hedefleyen uygulamalar ve kitaplıklar, [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) paketine doğrudan başvuruları kaldırmalıdır.

## <a name="jsonnet-support"></a>Json.NET desteği

[ASP.NET Core paylaşılan Framework 'ü geliştirmek](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)için çalışmanın bir parçası olarak, [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) ASP.NET Core paylaşılan çerçevesinden kaldırılmıştır. Bu başvuru, jsonpatch veya dönüştürücüler gibi belirli `Newtonsoft.Json`bir özellik kullanıyorsa [ya da bu](xref:web-api/advanced/formatting) `Newtonsoft.Json`başvuruya özgü türler ise, uygulamanız için gerekli olabilir.

ASP.NET Core 3,0 projesinde Json.NET kullanmak için:

* [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)öğesine bir paket başvurusu ekleyin.
* `Startup.ConfigureServices` Çağrılacak`AddNewtonsoftJson`güncelleştirme.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`, yeni MVC hizmeti kayıt yöntemleriyle uyumludur:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Json.NET ayarları şu çağrıda `AddNewtonsoftJson`ayarlanabilir:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC hizmeti kaydı

ASP.NET Core 3,0, içinde `Startup.ConfigureServices`MVC senaryolarını kaydetmek için yeni seçenekler ekler.

Üzerinde `IServiceCollection` MVC senaryolarıyla ilgili üç yeni en üst düzey uzantı yöntemi kullanılabilir. Şablonlar yerine `UseMvc`bu yeni yöntemleri kullanır. Ancak, `AddMvc` önceki sürümlerde olduğu gibi davranmaya devam eder.

Aşağıdaki örnek, denetleyiciler ve API ile ilgili özellikler için destek ekler, ancak görünümler veya sayfalar değildir. API şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Aşağıdaki örnek, denetleyiciler, API ile ilgili özellikler ve görünümler için destek ekler, ancak sayfalar için değildir. Web uygulaması (MVC) şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Aşağıdaki örnek, Razor Pages ve en düşük denetleyici desteği için destek ekler. Web uygulaması şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Yeni yöntemler de birleştirilebilir. Aşağıdaki örnek, ASP.NET Core 2,2 ' de `AddMvc` çağırma ile eşdeğerdir:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Yönlendirme başlangıç kodu

Bir uygulama veya `UseSignalR`olarak `UseMvc` çağırırsa, mümkünse uygulamayı [Endpoint Routing](xref:fundamentals/routing) 'e geçirin. MVC 'nin önceki sürümleriyle Endpoint Routing uyumluluğu geliştirmek için ASP.NET Core 2,2 ' de sunulan URL oluşturmayla ilgili bazı değişiklikleri geri çevirdik. 2,2 ' de Endpoint Routing kullanarak sorunlarla karşılaşırsanız, aşağıdaki özel durumlarla ASP.NET Core 3,0 ' de iyileştirmeler beklenir:

* Uygulama `IRouter` veya`Route`devralırsa, şu anda geçiş yapmaktan kaçınmak isteyebilirsiniz. [IRouter tabanlı uygulamaları Endpoint Routing 'e geçirmeyi planlıyoruz](https://github.com/aspnet/AspNetCore/issues/4221).

* Uygulama doğrudan MVC 'nin içine `RouteData.Routers` erişirse, şu anda geçiş yapmaktan kaçınmak isteyebilirsiniz. [RouteData. yönlendiricilerini kullanmaya yönelik geçiş kılavuzlarından](https://github.com/aspnet/AspNetCore/issues/9148)geri bildirim sağlayın.

Uç nokta yönlendirme, aynı yol deseninin sözdizimini ve yönlendirme deseninin yazma özelliklerini `IRouter`destekler. Uç nokta yönlendirme `IRouteConstraint`destekler. Endpoint Routing, `[Route]` `[HttpGet]`, ve diğer mvc yönlendirme özniteliklerini destekler.

Çoğu uygulama için yalnızca `Startup` değişiklik yapılması gerekir.

### <a name="migrate-startupconfigure"></a>Geçişi Başlat. yapılandırma

Genel öneri:

* Ekleyin `UseRouting`.
* Uygulama çağrııyorsa `UseStaticFiles`, daha **önce** `UseRouting`yerleştirin. `UseStaticFiles`
* Uygulama, veya `AuthorizePage` `[Authorize]`gibi kimlik doğrulama/yetkilendirme özelliklerini `UseAuthentication` kullanıyorsa, çağrıyı (CORS ara yazılımı kullanılıyorsa `UseAuthorization` **ve** `UseCors` sonrasında) ve **sonra** `UseRouting` da girin.
* Veya `UseMvc` ile`UseSignalR` değiştirin`UseEndpoints`.
* Uygulama gibi [CORS](xref:security/cors) senaryoları `[EnableCors]`kullanıyorsa, CORS 'yi kullanan diğer herhangi bir ara yazılım `UseCors` `UseAuthorization`(örneğin,, ve `UseEndpoints`' dan önce `UseAuthentication`yer `UseCors` alan) için çağrısı yapın.
* İle `IHostingEnvironment` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> değiştirin ve ad alanı `using` için bir ifade ekleyin. `IWebHostEnvironment`
* Öğesini ( <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> `IApplicationLifetime` ad<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> alanı) ile değiştirin.
* Öğesini ( <xref:Microsoft.Extensions.Hosting.Environments> `EnvironmentName` ad<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> alanı) ile değiştirin.

Aşağıda, tipik bir ASP.NET Core 2,2 `Startup.Configure` uygulamasında bir örneği verilmiştir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Önceki `Startup.Configure` kodu güncelleştirdikten sonra:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="health-checks"></a>Sistem durumu denetimleri

Sistem durumu denetimleri, genel ana bilgisayar ile Endpoint Routing kullanır. ' `Startup.Configure`De, `MapHealthChecks` uç nokta URL 'si veya göreli yol ile Endpoint Builder ' ı çağırın:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Durum denetimleri uç noktaları şunları yapabilir:

* İzin verilen bir veya daha fazla Konakları/bağlantı noktasını belirtin.
* Yetkilendirme gerektir.
* CORS gerektir.

Daha fazla bilgi için bkz. <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Güvenlik ara yazılımı Kılavuzu

Yetkilendirme ve CORS desteği, [Ara yazılım](xref:fundamentals/middleware/index) yaklaşımına göre birleştirilmiştir. Bu, bu senaryolarda aynı ara yazılım ve işlevselliğin kullanılmasına izin verir. Bu sürümde güncelleştirilmiş bir yetkilendirme ara yazılımı sunulmaktadır ve CORS ara yazılımı, MVC denetleyicileri tarafından kullanılan öznitelikleri anlayabilmesi için geliştirilmiştir.

#### <a name="cors"></a>CORS

Daha önce CORS yapılandırması zor olabilir. Ara yazılım bazı kullanım durumlarında kullanılmak üzere sağlandı, ancak MVC filtrelerinin diğer kullanım durumlarında ara yazılım **olmadan** kullanılması amaçlandı. ASP.NET Core 3,0 ile, CORS gerektiren tüm uygulamaların, uç nokta yönlendirme ile birlikte CORS ara yazılımını kullanması önerilir. `UseCors`, varsayılan bir ilkeyle ve `[EnableCors]` `[DisableCors]` gerekli olduğunda varsayılan ilkeyi geçersiz kılmak için öznitelikler kullanılabilir.

Aşağıdaki örnekte:

* CORS, `default` adlandırılmış ilkeye sahip tüm uç noktalar için etkinleştirilmiştir.
* Sınıfı, CORS `[DisableCors]` 'yi özniteliğiyle devre dışı bırakır. `MyController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Yetkilendirme

ASP.NET Core önceki sürümlerinde, yetkilendirme desteği `[Authorize]` özniteliği aracılığıyla sağlandı. Yetkilendirme ara yazılımı kullanılamıyor. ASP.NET Core 3,0 ' de, yetkilendirme ara yazılımı gereklidir. ASP.NET Core yetkilendirmesi ara yazılımını (`UseAuthorization`) hemen sonra `UseAuthentication`yerleştirmenizi öneririz. Yetkilendirme ara yazılımı, geçersiz kılınabilen varsayılan ilkeyle de yapılandırılabilir.

ASP.NET Core 3,0 veya üzeri `UseAuthorization` sürümlerde ' de `Startup.Configure`çağrılır ve aşağıdakiler `HomeController` oturum açmış bir kullanıcı gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Uygulama, MVC 'de Genel `AuthorizeFilter` bir filtre olarak kullanıyorsa, `AddAuthorization`çağrısına bir ilke sağlamak için kodu yeniden düzenlemeyi öneririz.

`DefaultPolicy` Başlangıçta kimlik doğrulaması gerektirecek şekilde yapılandırıldığında, ek yapılandırma gerekmez. Aşağıdaki örnekte, MVC uç noktaları, tüm isteklerin öğesine `RequireAuthorization` göre yetkilendirilmiş olması için `DefaultPolicy`olarak işaretlenir. Bununla birlikte, Kullanıcı uygulamada oturum açmadan erişime `[AllowAnonymous]` izinverir,çünkü:`HomeController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

İlkeler de özelleştirilebilir. Önceki örneğe `DefaultPolicy` derleme, kimlik doğrulaması ve belirli bir kapsam gerektirecek şekilde yapılandırılmıştır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternatif olarak, tüm uç noktalar bir `[Authorize]` `FallbackPolicy`veya `RequireAuthorization` yapılandırması olmadan yetkilendirme gerektirecek şekilde yapılandırılabilir. `FallbackPolicy` , Öğesinden`DefaultPolicy`farklıdır. , Veya `[Authorize]`tarafındantetiklenir , ancak`FallbackPolicy` başka bir ilke ayarlanmamışsa tetiklenir. `RequireAuthorization` `DefaultPolicy` `FallbackPolicy`Başlangıçta yetkilendirmesiz isteklere izin verecek şekilde yapılandırılmıştır.

Aşağıdaki örnek, önceki `DefaultPolicy` örnekle aynıdır, ancak belirtilen durumlar hariç `[AllowAnonymous]` tüm uç `FallbackPolicy` noktalarında her zaman kimlik doğrulaması gerektirmek için kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Belirli bir yetkilendirme bilgisine sahip olmayan, ara yazılım tarafından yetkilendirme çalışmaktadır. Örneğin, [sistem durumu denetimlerinde](xref:host-and-deploy/health-checks) belirli bir yetkilendirme bilgisi yoktur, ancak sistem durumu denetimleri, ara yazılım tarafından uygulanan yapılandırılabilir bir yetkilendirme ilkesine sahip olabilir.

Ayrıca, her uç nokta yetkilendirme gereksinimlerini özelleştirebilir. Aşağıdaki örnekte `UseAuthorization` , `DefaultPolicy`ile yetkilendirmeyi işler, ancak `/healthz` sistem durumu denetimi uç noktası bir `admin` Kullanıcı gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Koruma bazı senaryolar için uygulanır. `UseEndpoint`eksik bir ara yazılım nedeniyle yetkilendirme veya CORS ilkesi atlandıysa, ara yazılım bir özel durum oluşturur. Yanlış yapılandırma hakkında ek geribildirim sağlamak için çözümleyici desteği devam ediyor.

### <a name="signalr"></a>SignalR

SignalR hub 'larının eşlemesi artık içinde `UseEndpoints`yer alır.

Her hub 'ı ile `MapHub`eşleyin. Önceki sürümlerde olduğu gibi, her hub açık olarak listelenir.

Aşağıdaki örnekte, `ChatHub` SignalR hub 'ı için destek eklenmiştir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

İstemcilerden gelen ileti boyutu sınırlarını denetlemek için yeni bir seçenek vardır. Örneğin, içinde `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

ASP.NET Core 2,2 ' de, en büyük ileti `TransportMaxBufferSize` boyutunu etkin bir şekilde denetleyebilecek ve ' yi ayarlayabilirsiniz. ASP.NET Core 3,0 ' de, bu seçenek artık yalnızca geri basınç gözlemlenmeyen en büyük boyutu denetler.

### <a name="mvc-controllers"></a>MVC denetleyicileri

Denetleyicilerin eşlemesi artık içinde `UseEndpoints`yer alır.

Uygulama `MapControllers` öznitelik yönlendirme kullanıyorsa ekleyin. Yönlendirme ASP.NET Core 3,0 veya sonraki sürümlerde birçok çerçeve için destek içerdiğinden, öznitelik yönlendirmeli denetleyiciler eklemek kabul edilir.

Şunları değiştirin:

* `MapRoute`kullanılarak`MapControllerRoute`
* `MapAreaRoute`kullanılarak`MapAreaControllerRoute`

Yönlendirme şimdi yalnızca MVC 'den daha fazlasına destek içerdiğinden, bu yöntemlerin ne yapacaklarına açık bir şekilde sahip olması için terminoloji değişmiştir. Gibi `MapControllerRoute` geleneksel yollar `MapAreaControllerRoute` eklendikleri /sıraylauygulanır /. `MapDefaultControllerRoute` Önce daha belirli yollar (örneğin, bir alana yönelik yollar) yerleştirin.

Aşağıdaki örnekte:

* `MapControllers`öznitelik yönlendirmeli denetleyiciler için destek ekler.
* `MapAreaControllerRoute`bir alanındaki denetleyiciler için geleneksel bir yol ekler.
* `MapControllerRoute`denetleyiciler için geleneksel bir yol ekler.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Razor Pages

Eşleme Razor Pages artık içinde `UseEndpoints`yer alır.

Uygulama `MapRazorPages` Razor Pages kullanıyorsa ekleyin. Endpoint Routing birçok çerçeve için destek içerdiğinden Razor Pages eklemek artık tercih edilir.

Aşağıdaki örnekte `MapRazorPages` Razor Pages için destek ekler:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Endpoint Routing olmadan MVC kullanma

ASP.NET Core 3,0 aracılığıyla `UseMvc` veya `UseMvcWithDefaultRoute` içinde MVC kullanmanın içinde `Startup.ConfigureServices`açık bir kabul olması gerekir. Bu, MVC 'nin başlatma sırasında yetkilendirme ve CORS ara yazılımını kullanıp kullanamayacağını bilmeleri gerektiğinden gereklidir. Uygulama desteklenmeyen bir yapılandırmayı kullanmayı denerse sizi uyaran bir çözümleyici sağlanır.

Uygulama eski `IRouter` destek gerektiriyorsa, içinde `Startup.ConfigureServices`aşağıdaki yaklaşımlardan herhangi birini kullanarak devre dışı bırakın `EnableEndpointRouting` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Sistem durumu denetimleri

Sistem durumu denetimleri, uç nokta yönlendirme özellikli bir *yönlendirici-yazılım* olarak kullanılabilir.

Uç `MapHealthChecks` nokta yönlendirme ile durum denetimlerini kullanmak için ekleyin. Yöntemi şuna benzer bağımsız değişkenleri kabul eder. `UseHealthChecks` `MapHealthChecks` `MapHealthChecks` Kullanmanın`UseHealthChecks` avantajı, yetkilendirme uygulayabilir ve eşleşen ilke üzerinde daha ayrıntılı denetime sahip olabilir.

Aşağıdaki örnekte, `MapHealthChecks` şu konumda `/healthz`bir sistem durumu denetim uç noktası için çağrılır:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder WebHostBuilder 'ın yerini alır

ASP.NET Core 3,0 şablonları [genel konak](xref:fundamentals/host/generic-host)kullanır. Önceki sürümler [Web ana bilgisayarı](xref:fundamentals/host/web-host)kullandı. Aşağıdaki kod ASP.NET Core 3,0 şablonu oluşturulan `Program` sınıfını gösterir:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Aşağıdaki kod, ASP.NET Core 2,2 şablonu tarafından oluşturulan `Program` sınıfı gösterir:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>3,0 ' de kalır ve önceki kod örneğinde `webBuilder` görülen öğesinin türüdür. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>gelecekteki bir sürümde kullanımdan kaldırılacak ve tarafından `HostBuilder`değiştirilmeyecektir.

' Den `WebHostBuilder` ' ye `HostBuilder` en önemli değişiklik, [bağımlılık ekleme (dı)](xref:fundamentals/dependency-injection)içinde. Kullanırken `HostBuilder`, <xref:Microsoft.Extensions.Configuration.IConfiguration> yalnızca <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> oluşturucusunu ekleyebilir. `Startup` `HostBuilder` Dı kısıtlamaları:

* Dı kapsayıcısının yalnızca bir kez derlenme özelliğini etkinleştirin.
* Birden çok tekton örneğini çözümlemek gibi ortaya çıkan nesne ömrü sorunlarını önler.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addaduthorleştirme farklı bir derlemeye taşındı

`AddAuthorization` *Microsoft. aspnetcore. Authorization. dll*' deki ASP.NET Core 2,2 ve daha düşük Yöntemler:

* Yeniden adlandırıldı `AddAuthorizationCore`.
* , *Microsoft. AspNetCore. Authorization. Policy. dll*' ye taşınmıştır.

Hem *Microsoft. aspnetcore. Authorization. dll* hem de *Microsoft. Aspnetcore. Authorization. Policy. dll* ' i kullanan uygulamalar etkilenmez.

*Microsoft. AspNetCore. Authorization. Policy. dll* kullanmayan uygulamalar aşağıdakilerden birini yapmanız gerekir:

* Kullanmaya geç`AddAuthorizationCore`
* *Microsoft. AspNetCore. Authorization. Policy. dll*öğesine bir başvuru ekleyin.

Daha fazla bilgi için bkz. [' deki `AddAuthorization(o =>`Son değişiklik) farklı bir derlemede #386 aşırı yükleme yaşar](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>SignalR kodu

SignalR JavaScript istemcisi sürümünden `@aspnet/signalr` olarak `@microsoft/signalr`değiştirilmiştir. Bu değişikliğe tepki vermek için *Package. JSON* dosyalarındaki başvuruları değiştirin, deyimler gerektir ve ECMAScript import deyimlerini alın.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON varsayılan protokoldür

`System.Text.Json`, artık istemci ve sunucu tarafından kullanılan varsayılan Hub protokolüdür.

İçinde `Startup.ConfigureServices`, seri `AddJsonProtocol` hale getirici seçeneklerini ayarlamak için çağırın.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**İstemci:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft. JSON öğesine geç

' De `Newtonsoft.Json` `System.Text.Json`desteklenmeyen özellikleri kullanıyorsanız, ' ye `Newtonsoft.Json`geri dönebilirsiniz:

1. [Microsoft. AspNetCore. SignalR. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet paketini yükler.
1. İstemcisinde, `AddNewtonsoftJsonProtocol` `HubConnectionBuilder` örneğine bir yöntem çağrısı zincirleyebilirsiniz:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Sunucusunda, içinde `AddNewtonsoftJsonProtocol` `AddSignalR` yöntemçağrısınabiryöntemçağrısızincirleyebilirsiniz`Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Çalışma zamanı derlemesini kabul et

3,0 ' de, çalışma zamanı derlemesi bir katılım senaryosudur. Çalışma zamanı derlemesini etkinleştirmek için bkz <xref:mvc/views/view-compilation#runtime-compilation>.
